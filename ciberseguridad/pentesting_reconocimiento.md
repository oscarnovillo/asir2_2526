# Fase de Reconocimiento en Pentesting
## ASIR2 - Ciberseguridad

---

## √çndice
1. [Introducci√≥n al Reconocimiento](#introducci√≥n-al-reconocimiento)
2. [Tipos de Reconocimiento](#tipos-de-reconocimiento)
3. [Herramientas de Reconocimiento Web](#herramientas-de-reconocimiento-web)
4. [Reconocimiento de Dominios y Subdominios](#reconocimiento-de-dominios-y-subdominios)
5. [B√∫squeda de Informaci√≥n Corporativa](#b√∫squeda-de-informaci√≥n-corporativa)
6. [Escaneo de Puertos con Nmap](#escaneo-de-puertos-con-nmap)
7. [Alternativas a Nmap](#alternativas-a-nmap)
8. [Metodolog√≠a y Buenas Pr√°cticas](#metodolog√≠a-y-buenas-pr√°cticas)
9. [Ejercicios Pr√°cticos](#ejercicios-pr√°cticos)
10. [Recursos Adicionales](#recursos-adicionales)

---

## 1. Introducci√≥n al Reconocimiento

### ¬øQu√© es la Fase de Reconocimiento?

La fase de reconocimiento es la **primera y m√°s cr√≠tica etapa** de un test de penetraci√≥n. Durante esta fase, el pentester recopila toda la informaci√≥n posible sobre el objetivo sin interactuar directamente con sus sistemas.

### Objetivos Principales

- **Mapear la superficie de ataque** del objetivo
- **Identificar tecnolog√≠as** utilizadas
- **Descubrir subdominios** y servicios expuestos
- **Recopilar informaci√≥n** sobre empleados y estructura organizacional
- **Encontrar posibles vectores** de ataque inicial

### Marco Legal y √âtico

‚ö†Ô∏è **IMPORTANTE**: Todas las t√©cnicas mostradas deben utilizarse √∫nicamente en:
- Sistemas propios
- Entornos de laboratorio
- Auditor√≠as autorizadas por escrito
- Plataformas de pr√°ctica legales (HackTheBox, TryHackMe, etc.)

---

## 2. Tipos de Reconocimiento

### 2.1 Reconocimiento Pasivo

**Definici√≥n**: Recopilaci√≥n de informaci√≥n sin interactuar directamente con el objetivo.

**Caracter√≠sticas**:
- No genera logs en el objetivo
- Menor riesgo de detecci√≥n
- Utiliza fuentes p√∫blicas de informaci√≥n

**Fuentes comunes**:
- Motores de b√∫squeda
- Redes sociales
- Bases de datos p√∫blicas
- Servicios de inteligencia de amenazas

### 2.2 Reconocimiento Activo

**Definici√≥n**: Interacci√≥n directa con los sistemas del objetivo.

**Caracter√≠sticas**:
- Genera logs y tr√°fico detectable
- Proporciona informaci√≥n m√°s precisa
- Mayor riesgo de detecci√≥n

**T√©cnicas comunes**:
- Escaneo de puertos
- Enumeraci√≥n de servicios
- Pruebas de conectividad

---

## 3. Herramientas de Reconocimiento Web

### 3.1 Shodan

**Descripci√≥n**: Motor de b√∫squeda para dispositivos conectados a Internet.

**Caracter√≠sticas principales**:
- Indexa millones de dispositivos IoT
- Informaci√≥n sobre puertos abiertos
- Banners de servicios
- Geolocalizaci√≥n de dispositivos

**Sintaxis b√°sica de b√∫squeda**:

```bash
# B√∫squeda por IP
ip:192.168.1.1

# B√∫squeda por puerto
port:22

# B√∫squeda por servicio
apache

# B√∫squeda por pa√≠s
country:ES

# B√∫squeda por organizaci√≥n
org:"Telefonica"

# Combinaciones
apache country:ES port:443

# B√∫squeda de c√°maras web
title:"webcam" country:ES

# Servidores con vulnerabilidades espec√≠ficas
vuln:CVE-2014-0160
```

**Comandos √∫tiles**:
```bash
# Instalaci√≥n de Shodan CLI
pip install shodan

# Configurar API key
shodan init YOUR_API_KEY

# B√∫squeda b√°sica
shodan search apache

# Informaci√≥n de una IP espec√≠fica
shodan host 8.8.8.8

# Descargar resultados
shodan download resultados apache country:ES
```

### 3.2 Censys

**Descripci√≥n**: Plataforma de inteligencia de Internet que escanea y indexa dispositivos p√∫blicos.

**Ventajas sobre Shodan**:
- Datos m√°s actualizados
- Mejor an√°lisis de certificados SSL
- Interfaz m√°s intuitiva para principiantes

**Consultas √∫tiles**:
```bash
# B√∫squeda por dominio
services.http.response.html_title: "Apache"

# Certificados SSL
certificates.leaf_data.subject.common_name: "*.example.com"

# Servicios espec√≠ficos
services.service_name: SSH and location.country: Spain

# Puertos abiertos
services.port: 3389 and location.country_code: ES
```

### 3.3 Google Dorking

**T√©cnica**: Uso de operadores avanzados en Google para encontrar informaci√≥n espec√≠fica.

**Operadores esenciales**:
```bash
# B√∫squeda en sitio espec√≠fico
site:ejemplo.com

# Tipo de archivo espec√≠fico
filetype:pdf site:ejemplo.com

# Texto en URL
inurl:admin

# Texto en t√≠tulo
intitle:"index of"

# Texto espec√≠fico en p√°gina
intext:"password"

# P√°ginas similares
related:ejemplo.com

# Cache de Google
cache:ejemplo.com

# Informaci√≥n del sitio
info:ejemplo.com
```

**Dorks √∫tiles para pentesting**:
```bash
# Archivos de configuraci√≥n
filetype:conf inurl:conf

# Bases de datos expuestas
filetype:sql

# Documentos con informaci√≥n sensible
filetype:xls site:ejemplo.com "confidential"

# Paneles de administraci√≥n
inurl:admin intitle:login

# Archivos de backup
filetype:bak site:ejemplo.com

# Directorios listables
intitle:"index of" site:ejemplo.com
```

---

## 4. Reconocimiento de Dominios y Subdominios

### 4.1 Informaci√≥n WHOIS

**Herramientas**:
```bash
# Comando whois tradicional
whois ejemplo.com

# Online: whois.net, whois.com
```

**Informaci√≥n obtenible**:
- Registrador del dominio
- Fechas de registro y expiraci√≥n
- Servidores DNS
- Informaci√≥n de contacto (si no est√° protegida)
- Historial de cambios

### 4.2 Enumeraci√≥n de Subdominios

#### 4.2.1 Subfinder
```bash
# Instalaci√≥n
go install -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest

# Uso b√°sico
subfinder -d ejemplo.com

# Guardar resultados
subfinder -d ejemplo.com -o subdominios.txt

# Usar m√∫ltiples fuentes
subfinder -d ejemplo.com -all
```

#### 4.2.2 Amass
```bash
# Instalaci√≥n
sudo apt install amass

# Enumeraci√≥n pasiva
amass enum -passive -d ejemplo.com

# Enumeraci√≥n activa
amass enum -active -d ejemplo.com

# Con resoluci√≥n DNS
amass enum -active -d ejemplo.com -r 8.8.8.8,1.1.1.1
```

#### 4.2.3 Sublist3r
```bash
# Instalaci√≥n
git clone https://github.com/aboul3la/Sublist3r.git
cd Sublist3r
pip install -r requirements.txt

# Uso b√°sico
python sublist3r.py -d ejemplo.com

# Con bruteforce
python sublist3r.py -d ejemplo.com -b

# Especificar threads
python sublist3r.py -d ejemplo.com -t 100
```

#### 4.2.4 Gobuster (DNS)
```bash
# Instalaci√≥n
sudo apt install gobuster

# Enumeraci√≥n de subdominios
gobuster dns -d ejemplo.com -w /usr/share/wordlists/SecLists/Discovery/DNS/subdomains-top1million-5000.txt

# Con m√∫ltiples threads
gobuster dns -d ejemplo.com -w wordlist.txt -t 50
```

### 4.3 An√°lisis de DNS

#### 4.3.1 Registros DNS importantes
```bash
# Registro A (IPv4)
dig A ejemplo.com

# Registro AAAA (IPv6)
dig AAAA ejemplo.com

# Registro MX (Mail Exchange)
dig MX ejemplo.com

# Registro TXT (informaci√≥n adicional)
dig TXT ejemplo.com

# Registro NS (Name Servers)
dig NS ejemplo.com

# Registro CNAME (Alias)
dig CNAME www.ejemplo.com

# Todos los registros
dig ANY ejemplo.com
```

#### 4.3.2 Transferencia de zona DNS
```bash
# Intentar transferencia de zona
dig axfr ejemplo.com @ns1.ejemplo.com

# Con nslookup
nslookup
> set type=any
> ls -d ejemplo.com
```

#### 4.3.3 DNS Reverse Lookup
```bash
# Lookup inverso
dig -x 192.168.1.1

# Con nslookup
nslookup 192.168.1.1
```

---

## 5. B√∫squeda de Informaci√≥n Corporativa

### 5.1 B√∫squeda de Empleados

#### 5.1.1 LinkedIn
- **B√∫squeda manual**: Utilizar filtros avanzados
- **Herramientas automatizadas**: 
  - LinkedIn2Username
  - CrossLinked

```bash
# CrossLinked - B√∫squeda de empleados en LinkedIn
python3 crosslinked.py -f "full_names.txt" "CompanyName"

# LinkedIn2Username - Generar usuarios potenciales
python linkedin2username.py "Company Name"
```

#### 5.1.2 Hunter.io
```bash
# B√∫squeda de emails por dominio
# Via web: hunter.io

# Patrones comunes de email:
# nombre.apellido@empresa.com
# n.apellido@empresa.com
# nombre@empresa.com
# napellido@empresa.com
```

#### 5.1.3 theHarvester
```bash
# Instalaci√≥n
sudo apt install theharvester

# B√∫squeda de emails
theharvester -d ejemplo.com -b google

# M√∫ltiples fuentes
theharvester -d ejemplo.com -b google,bing,yahoo

# Limitar resultados
theharvester -d ejemplo.com -l 100 -b google

# Guardar resultados
theharvester -d ejemplo.com -b all -f resultados.html
```

### 5.2 Informaci√≥n en Redes Sociales

#### Herramientas OSINT
```bash
# Sherlock - Buscar usernames en redes sociales
python3 sherlock usuario

# Social-Analyzer - An√°lisis de perfiles sociales
python3 social-analyzer.py --username "john_doe"

# Twint - An√°lisis de Twitter
twint -u username --email
```

### 5.3 Documentos y Metadatos

#### 5.3.1 FOCA (Windows)
- B√∫squeda autom√°tica de documentos
- Extracci√≥n de metadatos
- An√°lisis de informaci√≥n sensible

#### 5.3.2 Metagoofil
```bash
# Instalaci√≥n
git clone https://github.com/laramies/metagoofil.git

# B√∫squeda de documentos PDF
python3 metagoofil.py -d ejemplo.com -t pdf -l 100

# M√∫ltiples tipos de archivo
python3 metagoofil.py -d ejemplo.com -t pdf,doc,xls,ppt -l 200
```

#### 5.3.3 ExifTool
```bash
# An√°lisis de metadatos de archivos
exiftool documento.pdf
exiftool imagen.jpg

# Eliminar metadatos
exiftool -all= archivo.jpg
```

---

## 6. Escaneo de Puertos con Nmap

### 6.1 Conceptos B√°sicos

**Estados de puertos en Nmap**:
- **Open**: Puerto abierto y servicio respondiendo
- **Closed**: Puerto cerrado pero accesible
- **Filtered**: Puerto filtrado por firewall
- **Unfiltered**: Puerto accesible pero estado indeterminado
- **Open|Filtered**: No se puede determinar si est√° abierto o filtrado
- **Closed|Filtered**: No se puede determinar si est√° cerrado o filtrado

### 6.2 Sintaxis B√°sica

```bash
# Escaneo b√°sico
nmap ejemplo.com

# Especificar puertos
nmap -p 80,443 ejemplo.com

# Rango de puertos
nmap -p 1-1000 ejemplo.com

# Todos los puertos
nmap -p- ejemplo.com

# Puertos m√°s comunes
nmap --top-ports 100 ejemplo.com
```

### 6.3 Tipos de Escaneo

#### 6.3.1 Escaneo TCP
```bash
# TCP SYN scan (por defecto con privilegios)
nmap -sS ejemplo.com

# TCP Connect scan (sin privilegios)
nmap -sT ejemplo.com

# TCP ACK scan (detecci√≥n de firewalls)
nmap -sA ejemplo.com

# TCP Window scan
nmap -sW ejemplo.com

# TCP FIN scan (evasi√≥n)
nmap -sF ejemplo.com

# TCP Null scan (evasi√≥n)
nmap -sN ejemplo.com

# TCP Xmas scan (evasi√≥n)
nmap -sX ejemplo.com
```

#### 6.3.2 Escaneo UDP
```bash
# UDP scan (lento pero importante)
nmap -sU ejemplo.com

# UDP en puertos espec√≠ficos
nmap -sU -p 53,161,162 ejemplo.com

# Combinado TCP y UDP
nmap -sS -sU -p T:80,443,U:53,161 ejemplo.com
```

### 6.4 Detecci√≥n de Servicios y Versiones

```bash
# Detecci√≥n de servicios
nmap -sV ejemplo.com

# Detecci√≥n de SO
nmap -O ejemplo.com

# Detecci√≥n agresiva (OS + servicios + scripts)
nmap -A ejemplo.com

# Intensidad de detecci√≥n
nmap -sV --version-intensity 9 ejemplo.com

# Solo detecci√≥n de servicios sin ping
nmap -sV -Pn ejemplo.com
```

### 6.5 Scripts de Nmap (NSE)

```bash
# Listar categor√≠as de scripts
nmap --script-help

# Scripts por defecto
nmap -sC ejemplo.com

# Scripts de vulnerabilidades
nmap --script vuln ejemplo.com

# Scripts espec√≠ficos
nmap --script http-title,http-headers ejemplo.com

# Scripts de fuerza bruta
nmap --script brute ejemplo.com

# Scripts de enumeraci√≥n
nmap --script enum ejemplo.com

# Script espec√≠fico para HTTP
nmap --script http-enum ejemplo.com

# Actualizar base de datos de scripts
nmap --script-updatedb
```

### 6.6 T√©cnicas de Evasi√≥n

```bash
# Fragmentar paquetes
nmap -f ejemplo.com

# Fragmentar con MTU espec√≠fico
nmap --mtu 24 ejemplo.com

# Usar se√±uelos
nmap -D RND:10 ejemplo.com

# IP de origen falsa
nmap -S 192.168.1.5 ejemplo.com

# Interfaz espec√≠fica
nmap -e eth0 ejemplo.com

# Timing (de 0 paranoid a 5 insane)
nmap -T4 ejemplo.com

# Delays personalizados
nmap --scan-delay 1s ejemplo.com

# Randomizar orden de hosts
nmap --randomize-hosts 192.168.1.0/24
```

### 6.7 Salida y Logging

```bash
# Salida normal
nmap -oN scan.txt ejemplo.com

# Salida XML
nmap -oX scan.xml ejemplo.com

# Salida greppable
nmap -oG scan.grep ejemplo.com

# Todas las salidas
nmap -oA scan ejemplo.com

# Salida a stdout y archivo
nmap ejemplo.com | tee scan.txt

# Verbosidad
nmap -v ejemplo.com
nmap -vv ejemplo.com
```

### 6.8 Ejemplos Pr√°cticos

```bash
# Escaneo completo de red local
nmap -sS -O -sV -A 192.168.1.0/24

# Escaneo r√°pido de puertos comunes
nmap -F -T4 ejemplo.com

# Escaneo sigiloso
nmap -sS -T2 -f ejemplo.com

# Descubrimiento de hosts activos
nmap -sn 192.168.1.0/24

# Escaneo de servicios web
nmap -p 80,443,8080,8443 --script http-title,http-headers ejemplo.com

# B√∫squeda de vulnerabilidades espec√≠ficas
nmap -p 445 --script smb-vuln-* ejemplo.com
```

---

## 7. Alternativas a Nmap

### 7.1 Masscan

**Caracter√≠sticas**:
- Extremadamente r√°pido
- Capaz de escanear toda Internet
- Limitado en detecci√≥n de servicios

```bash
# Instalaci√≥n
sudo apt install masscan

# Escaneo b√°sico
masscan -p80,443 192.168.1.0/24

# Escaneo r√°pido de red grande
masscan -p1-65535 10.0.0.0/8 --rate=1000

# Guardar resultados
masscan -p80,443 192.168.1.0/24 -oX scan.xml

# Configuraci√≥n avanzada
masscan -p80,443 --rate=1000 --router-ip 192.168.1.1 192.168.1.0/24
```

### 7.2 Zmap

**Caracter√≠sticas**:
- Dise√±ado para escaneos de Internet completa
- Muy eficiente para escaneos de un solo puerto

```bash
# Instalaci√≥n
sudo apt install zmap

# Escaneo de puerto espec√≠fico en red grande
zmap -p 80 10.0.0.0/8

# Con salida espec√≠fica
zmap -p 443 192.168.1.0/24 -o resultados.txt

# Escaneo con rate limiting
zmap -p 22 10.0.0.0/16 -r 1000
```

### 7.3 RustScan

**Caracter√≠sticas**:
- Escrito en Rust (muy r√°pido)
- Integraci√≥n con Nmap
- Interfaz moderna

```bash
# Instalaci√≥n
cargo install rustscan

# O con apt en algunas distribuciones
sudo apt install rustscan

# Escaneo b√°sico (usa todos los puertos)
rustscan -a ejemplo.com

# Escaneo con Nmap integration
rustscan -a ejemplo.com -- -sC -sV

# Escaneo de rango
rustscan -a 192.168.1.0/24

# Especificar puertos
rustscan -a ejemplo.com -p 80,443,22
```

### 7.4 Unicornscan

**Caracter√≠sticas**:
- Escaneo as√≠ncrono
- Bueno para evasi√≥n
- Menos mantenido actualmente

```bash
# Instalaci√≥n
sudo apt install unicornscan

# Escaneo TCP
unicornscan -mT ejemplo.com:1-1000

# Escaneo UDP
unicornscan -mU ejemplo.com:1-1000

# Con rate limiting
unicornscan -r 300 -mT ejemplo.com:1-65535
```

### 7.5 Hping3

**Caracter√≠sticas**:
- Generador de paquetes personalizado
- √ötil para pruebas espec√≠ficas
- Capacidades de firewall testing

```bash
# Instalaci√≥n
sudo apt install hping3

# Ping TCP a puerto espec√≠fico
hping3 -S -p 80 ejemplo.com

# Escaneo de puertos TCP
hping3 -S --scan 1-1000 ejemplo.com

# Test de firewall
hping3 -A -p 80 ejemplo.com

# Fragmentaci√≥n
hping3 -S -p 80 -f ejemplo.com
```

---

## 8. Metodolog√≠a y Buenas Pr√°cticas

### 8.1 Proceso Estructurado

#### Fase 1: Recopilaci√≥n Pasiva
1. **B√∫squeda OSINT inicial**
   - Google Dorking
   - Shodan/Censys
   - Informaci√≥n corporativa

2. **An√°lisis de dominios**
   - WHOIS
   - DNS records
   - Subdominios

3. **Recopilaci√≥n de contactos**
   - Empleados
   - Emails
   - Estructura organizacional

#### Fase 2: Recopilaci√≥n Activa
1. **Descubrimiento de hosts**
   - Ping sweeps
   - ARP scanning (redes locales)

2. **Escaneo de puertos**
   - Puertos comunes primero
   - Escaneo completo despu√©s
   - UDP en servicios cr√≠ticos

3. **Enumeraci√≥n de servicios**
   - Detecci√≥n de versiones
   - Banner grabbing
   - Scripts especializados

### 8.2 Documentaci√≥n

**Template de informe de reconocimiento**:
```markdown
# Informe de Reconocimiento - [Objetivo]
## Fecha: [Fecha]
## Auditor: [Nombre]

### 1. Informaci√≥n del Dominio
- **Dominio principal**: 
- **Registrador**: 
- **Fecha de registro**: 
- **Servidores DNS**: 

### 2. Subdominios Encontrados
- subdominio1.ejemplo.com (IP: X.X.X.X)
- subdominio2.ejemplo.com (IP: Y.Y.Y.Y)

### 3. Servicios Identificados
| IP | Puerto | Servicio | Versi√≥n |
|----|--------|----------|---------|
| X.X.X.X | 80 | HTTP | Apache 2.4.41 |
| X.X.X.X | 443 | HTTPS | Apache 2.4.41 |

### 4. Informaci√≥n de Contactos
- **Emails encontrados**: 
- **Empleados identificados**: 

### 5. Posibles Vectores de Ataque
- [ ] Servicios desactualizados
- [ ] Puertos innecesarios abiertos
- [ ] Informaci√≥n sensible expuesta

### 6. Recomendaciones
1. Cerrar puertos innecesarios
2. Actualizar servicios desactualizados
3. Implementar rate limiting
```

### 8.3 Consideraciones Legales y √âticas

#### ‚úÖ Actividades Permitidas
- Reconocimiento en sistemas propios
- Uso de informaci√≥n p√∫blica disponible
- Auditor√≠as con autorizaci√≥n escrita
- Pr√°ctica en laboratorios dedicados

#### ‚ùå Actividades Prohibidas
- Escaneo no autorizado de sistemas ajenos
- Acceso a sistemas sin permiso
- Disruption de servicios
- Uso malicioso de informaci√≥n obtenida

#### üìã Checklist de Autorizaci√≥n
- [ ] Autorizaci√≥n escrita del propietario
- [ ] Alcance claramente definido
- [ ] Horarios de trabajo establecidos
- [ ] Contactos de emergencia definidos
- [ ] Procedimientos de escalado establecidos

---

## 9. Ejercicios Pr√°cticos

### 9.1 Ejercicio 1: Reconocimiento B√°sico

**Objetivo**: Realizar reconocimiento pasivo de un dominio.

**Pasos**:
1. Elegir un dominio p√∫blico (ej: ejemplo.edu)
2. Realizar b√∫squeda WHOIS
3. Enumerar subdominios con al menos 2 herramientas
4. Buscar informaci√≥n en Shodan
5. Documentar hallazgos

**Deliverable**: Informe de 2 p√°ginas con hallazgos.

### 9.2 Ejercicio 2: Escaneo con Nmap

**Objetivo**: Realizar escaneo completo de red de laboratorio.

**Entorno**: VirtualBox/VMware con m√°quinas vulnerables (Metasploitable, DVWA)

**Pasos**:
1. Descubrimiento de hosts
2. Escaneo de puertos TCP top 1000
3. Escaneo UDP en puertos comunes
4. Detecci√≥n de servicios y versiones
5. Ejecuci√≥n de scripts NSE relevantes

**Deliverable**: Reporte t√©cnico con comandos utilizados y resultados.

### 9.3 Ejercicio 3: Comparaci√≥n de Herramientas

**Objetivo**: Comparar eficiencia de diferentes scanners.

**Herramientas a comparar**:
- Nmap
- Masscan
- RustScan

**M√©tricas a evaluar**:
- Tiempo de ejecuci√≥n
- Precisi√≥n de resultados
- Recursos utilizados
- Facilidad de uso

**Deliverable**: Tabla comparativa con an√°lisis.

### 9.4 Ejercicio 4: OSINT Challenge

**Objetivo**: Extraer informaci√≥n de una organizaci√≥n ficticia.

**Tareas**:
1. Encontrar empleados usando LinkedIn
2. Generar lista de emails potenciales
3. Buscar documentos con metadatos
4. Crear organigrama parcial
5. Identificar tecnolog√≠as utilizadas

**Deliverable**: Dossier de inteligencia organizacional.

---

## 10. Recursos Adicionales

### 10.1 Herramientas Adicionales

#### Reconocimiento Web
- **Wappalyzer**: Identificaci√≥n de tecnolog√≠as web
- **Builtwith**: An√°lisis de tecnolog√≠as de sitios web
- **Netcraft**: Informaci√≥n de hosting y tecnolog√≠as
- **SecurityHeaders**: An√°lisis de headers de seguridad

#### OSINT
- **Maltego**: Plataforma de an√°lisis de enlaces
- **Spiderfoot**: Framework de automatizaci√≥n OSINT
- **Recon-ng**: Framework de reconocimiento modular
- **Photon**: Crawler para OSINT

#### DNS y Dominios
- **DNSRecon**: Enumeraci√≥n de DNS avanzada
- **DNSenum**: Enumeraci√≥n de informaci√≥n DNS
- **Fierce**: Esc√°ner de dominios
- **DNSmap**: Scanner de subdominios

### 10.2 Wordlists Importantes

```bash
# SecLists (colecci√≥n completa)
/usr/share/wordlists/SecLists/Discovery/DNS/
/usr/share/wordlists/SecLists/Discovery/Web-Content/
/usr/share/wordlists/SecLists/Usernames/

# Ubicaciones comunes en Kali Linux
/usr/share/wordlists/dirb/
/usr/share/wordlists/dirbuster/
/usr/share/wordlists/wfuzz/
```

### 10.3 Plataformas de Pr√°ctica

#### Gratuitas
- **TryHackMe**: Rooms de OSINT y reconocimiento
- **HackTheBox**: M√°quinas para practicar reconocimiento
- **VulnHub**: M√°quinas virtuales vulnerables
- **DVWA**: Aplicaci√≥n web deliberadamente vulnerable

#### De Pago
- **Cybrary**: Cursos de ethical hacking
- **PentesterLab**: Laboratorios web espec√≠ficos
- **eLearnSecurity**: Cursos avanzados de pentesting

### 10.4 Documentaci√≥n y Referencias

#### Oficiales
- **Nmap Reference Guide**: https://nmap.org/book/
- **OWASP Testing Guide**: https://owasp.org/www-project-web-security-testing-guide/
- **NIST Cybersecurity Framework**: https://www.nist.gov/cybersecurity

#### Libros Recomendados
- "The Web Application Hacker's Handbook" - Stuttard & Pinto
- "Penetration Testing: A Hands-On Introduction" - Weidman
- "Open Source Intelligence Techniques" - Bazzell

#### Blogs y Recursos Online
- **Null-byte (WonderHowTo)**: Tutoriales de hacking √©tico
- **InfoSec Institute**: Art√≠culos t√©cnicos
- **SANS Reading Room**: Papers t√©cnicos gratuitos

### 10.5 Comandos de Referencia R√°pida

#### Nmap Quick Reference
```bash
# Escaneos b√°sicos
nmap -sS -O -sV target          # Stealth + OS + Version detection
nmap -A target                  # Aggressive scan
nmap -sU --top-ports 100 target # UDP top ports
nmap --script vuln target       # Vulnerability scripts

# Timing y performance
nmap -T4 target                 # Fast timing
nmap --max-retries 1 target     # Reduce retries
nmap --host-timeout 5m target   # Timeout per host
```

#### Subdomain Enumeration
```bash
# Multiple tools pipeline
subfinder -d target.com | amass enum -passive -d target.com | sort -u > subs.txt
```

#### DNS Quick Checks
```bash
# Essential DNS records
dig target.com A MX NS TXT
```

---

## Conclusiones

La fase de reconocimiento es fundamental en cualquier auditor√≠a de seguridad. Una recopilaci√≥n exhaustiva de informaci√≥n puede marcar la diferencia entre un pentesting exitoso y uno superficial.

### Puntos Clave:
1. **La paciencia es crucial** - El reconocimiento no debe ser apresurado
2. **Combinar herramientas** - Ninguna herramienta es perfecta por s√≠ sola
3. **Documentar todo** - La informaci√≥n recopilada es valiosa para fases posteriores
4. **Respetar l√≠mites legales** - Solo trabajar en entornos autorizados
5. **Mantenerse actualizado** - Las herramientas y t√©cnicas evolucionan constantemente

### Pr√≥ximos Pasos:
- Pr√°ctica regular con laboratorios
- Participaci√≥n en CTFs
- Contribuci√≥n a proyectos open source
- Obtenci√≥n de certificaciones (CEH, OSCP, etc.)

---

**Nota**: Este material est√° dise√±ado con fines educativos para estudiantes de ASIR2. El uso de estas t√©cnicas debe limitarse siempre a entornos autorizados y con prop√≥sitos leg√≠timos de aprendizaje y auditor√≠a de seguridad.

**Autor**: [Nombre del profesor/instructor]  
**Fecha**: Septiembre 2025

---

## 11. Laboratorios Pr√°cticos Detallados

### 11.1 Laboratorio 1: Configuraci√≥n del Entorno

#### Requisitos del Sistema
```bash
# Sistema operativo recomendado
- Kali Linux 2023.3 o superior
- Parrot Security OS
- Ubuntu/Debian con herramientas instaladas manualmente

# Recursos m√≠nimos
- RAM: 4GB (recomendado 8GB)
- Almacenamiento: 50GB libre
- Conexi√≥n a Internet estable
```

#### Instalaci√≥n de Herramientas Esenciales
```bash
# Actualizar sistema
sudo apt update && sudo apt upgrade -y

# Instalar herramientas b√°sicas
sudo apt install -y nmap masscan rustscan gobuster subfinder amass \
theharvester shodan whatweb nikto dirb dirbuster wpscan \
sqlmap metasploit-framework exploitdb searchsploit

# Instalar herramientas adicionales
sudo apt install -y dnsrecon dnsenum fierce dnsmap recon-ng \
spiderfoot maltego photon osrframework holehe sherlock

# Herramientas de Python
pip3 install shodan censys requests beautifulsoup4 python-whois \
dnspython sublist3r builtwith-python

# Configuraci√≥n de API keys (opcional)
mkdir ~/.config/
# Shodan API
echo "YOUR_SHODAN_API_KEY" > ~/.config/shodan_api_key
# Censys API
echo "YOUR_CENSYS_API_ID:YOUR_CENSYS_API_SECRET" > ~/.config/censys_api
```

#### Configuraci√≥n de Laboratorio Virtual
```bash
# Descargar m√°quinas vulnerables para pr√°ctica
wget https://download.vulnhub.com/metasploitable/metasploitable-linux-2.0.0.zip
wget https://sourceforge.net/projects/dvwa/files/DVWA-1.10.zip

# Configurar red aislada en VirtualBox/VMware
# Red NAT para acceso a Internet
# Red interna para m√°quinas vulnerables
```

### 11.2 Laboratorio 2: Reconocimiento Pasivo Avanzado

#### Objetivo
Realizar reconocimiento completo de una organizaci√≥n sin interactuar directamente con sus sistemas.

#### Ejercicio Pr√°ctico: An√°lisis de "MegaCorp Inc."

**Paso 1: B√∫squeda inicial con Google Dorking**
```bash
# Crear script para automatizar b√∫squedas
#!/bin/bash
# google_dorking.sh

TARGET="megacorp.com"
OUTPUT_DIR="recon_results"

mkdir -p $OUTPUT_DIR

echo "[+] Iniciando reconocimiento pasivo de $TARGET"

# B√∫squeda de subdominios
echo "[*] Buscando subdominios..."
curl -s "https://www.google.com/search?q=site:$TARGET" | \
grep -oP "https?://[^/]*$TARGET" | sort -u > $OUTPUT_DIR/google_subdomains.txt

# B√∫squeda de archivos espec√≠ficos
echo "[*] Buscando archivos PDF..."
curl -s "https://www.google.com/search?q=site:$TARGET+filetype:pdf" | \
grep -oP "https?://[^\"]*\.pdf" > $OUTPUT_DIR/pdf_files.txt

echo "[*] B√∫squeda completada. Revisar $OUTPUT_DIR/"
```

**Paso 2: An√°lisis con Shodan**
```python
#!/usr/bin/env python3
# shodan_recon.py

import shodan
import json
import sys

API_KEY = "YOUR_SHODAN_API_KEY"
api = shodan.Shodan(API_KEY)

def search_organization(org_name):
    try:
        # B√∫squeda por organizaci√≥n
        results = api.search(f'org:"{org_name}"')
        
        print(f"[+] Encontrados {results['total']} resultados para {org_name}")
        
        for result in results['matches']:
            print(f"IP: {result['ip_str']}")
            print(f"Puerto: {result['port']}")
            print(f"Servicio: {result.get('product', 'Unknown')}")
            print(f"Versi√≥n: {result.get('version', 'Unknown')}")
            print(f"Pa√≠s: {result['location']['country_name']}")
            print("-" * 50)
            
    except shodan.APIError as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Uso: python3 shodan_recon.py 'Organization Name'")
        sys.exit(1)
    
    search_organization(sys.argv[1])
```

**Paso 3: Enumeraci√≥n masiva de subdominios**
```bash
#!/bin/bash
# subdomain_enum.sh

TARGET=$1
OUTPUT_DIR="subdomains_$TARGET"

if [ -z "$TARGET" ]; then
    echo "Uso: $0 <domain>"
    exit 1
fi

mkdir -p $OUTPUT_DIR

echo "[+] Enumerando subdominios para $TARGET"

# Subfinder
echo "[*] Ejecutando Subfinder..."
subfinder -d $TARGET -silent > $OUTPUT_DIR/subfinder.txt

# Amass
echo "[*] Ejecutando Amass (pasivo)..."
amass enum -passive -d $TARGET > $OUTPUT_DIR/amass.txt

# Sublist3r
echo "[*] Ejecutando Sublist3r..."
python3 /opt/Sublist3r/sublist3r.py -d $TARGET -o $OUTPUT_DIR/sublist3r.txt

# Assetfinder
echo "[*] Ejecutando Assetfinder..."
assetfinder --subs-only $TARGET > $OUTPUT_DIR/assetfinder.txt

# Findomain
echo "[*] Ejecutando Findomain..."
findomain -t $TARGET -q > $OUTPUT_DIR/findomain.txt

# Combinar y limpiar resultados
echo "[*] Combinando resultados..."
cat $OUTPUT_DIR/*.txt | sort -u | grep -v "^\s*$" > $OUTPUT_DIR/all_subdomains.txt

# Verificar subdominios activos
echo "[*] Verificando subdominios activos..."
while read subdomain; do
    if dig +short $subdomain | grep -q .; then
        echo $subdomain >> $OUTPUT_DIR/active_subdomains.txt
    fi
done < $OUTPUT_DIR/all_subdomains.txt

echo "[+] Enumeraci√≥n completada:"
echo "    Total encontrados: $(cat $OUTPUT_DIR/all_subdomains.txt | wc -l)"
echo "    Activos: $(cat $OUTPUT_DIR/active_subdomains.txt | wc -l)"
```

### 11.3 Laboratorio 3: Escaneo Avanzado con Nmap

#### Scripts Personalizados NSE

**Script personalizado para detecci√≥n web**
```lua
-- http-custom-enum.nse
description = [[
Enumeraci√≥n personalizada de servicios HTTP
Detecta tecnolog√≠as, frameworks y posibles vulnerabilidades
]]

author = "Estudiante ASIR2"
license = "GPL v2"
categories = {"discovery", "safe"}

local http = require "http"
local shortport = require "shortport"
local stdnse = require "stdnse"

portrule = shortport.http

action = function(host, port)
    local result = {}
    
    -- Obtener headers
    local response = http.get(host, port, "/")
    if not response or not response.header then
        return nil
    end
    
    -- Analizar Server header
    if response.header.server then
        table.insert(result, "Server: " .. response.header.server)
    end
    
    -- Analizar X-Powered-By
    if response.header["x-powered-by"] then
        table.insert(result, "X-Powered-By: " .. response.header["x-powered-by"])
    end
    
    -- Buscar frameworks en HTML
    if response.body then
        if string.find(response.body:lower(), "wordpress") then
            table.insert(result, "Framework: WordPress detectado")
        elseif string.find(response.body:lower(), "drupal") then
            table.insert(result, "Framework: Drupal detectado")
        elseif string.find(response.body:lower(), "joomla") then
            table.insert(result, "Framework: Joomla detectado")
        end
    end
    
    return stdnse.format_output(true, result)
end
```

**Uso del script personalizado**
```bash
# Copiar script a directorio NSE
sudo cp http-custom-enum.nse /usr/share/nmap/scripts/

# Actualizar base de datos
sudo nmap --script-updatedb

# Usar script personalizado
nmap --script http-custom-enum ejemplo.com
```

#### Plantillas de Escaneo Automatizado

```bash
#!/bin/bash
# nmap_comprehensive.sh

TARGET=$1
OUTPUT_DIR="nmap_scan_$(date +%Y%m%d_%H%M%S)"

if [ -z "$TARGET" ]; then
    echo "Uso: $0 <target>"
    exit 1
fi

mkdir -p $OUTPUT_DIR

echo "[+] Iniciando escaneo comprehensivo de $TARGET"
echo "[*] Resultados en: $OUTPUT_DIR"

# Paso 1: Descubrimiento de hosts
echo "[*] Paso 1: Descubrimiento de hosts..."
nmap -sn $TARGET -oA $OUTPUT_DIR/01_host_discovery

# Paso 2: Escaneo r√°pido de puertos comunes
echo "[*] Paso 2: Escaneo r√°pido de puertos..."
nmap -sS -T4 -F $TARGET -oA $OUTPUT_DIR/02_fast_scan

# Paso 3: Escaneo completo de puertos TCP
echo "[*] Paso 3: Escaneo completo TCP..."
nmap -sS -p- -T4 $TARGET -oA $OUTPUT_DIR/03_full_tcp

# Paso 4: Escaneo UDP en puertos comunes
echo "[*] Paso 4: Escaneo UDP..."
nmap -sU --top-ports 100 $TARGET -oA $OUTPUT_DIR/04_udp_scan

# Paso 5: Detecci√≥n de servicios y versiones
echo "[*] Paso 5: Detecci√≥n de servicios..."
nmap -sS -sV -A -T4 $TARGET -oA $OUTPUT_DIR/05_service_detection

# Paso 6: Scripts de vulnerabilidades
echo "[*] Paso 6: B√∫squeda de vulnerabilidades..."
nmap --script vuln $TARGET -oA $OUTPUT_DIR/06_vulnerability_scan

# Paso 7: Scripts espec√≠ficos por servicio
echo "[*] Paso 7: Scripts espec√≠ficos..."

# HTTP/HTTPS
nmap --script "http-*" -p 80,443,8080,8443 $TARGET -oA $OUTPUT_DIR/07_http_scripts

# SSH
nmap --script "ssh-*" -p 22 $TARGET -oA $OUTPUT_DIR/07_ssh_scripts

# SMB
nmap --script "smb-*" -p 139,445 $TARGET -oA $OUTPUT_DIR/07_smb_scripts

# DNS
nmap --script "dns-*" -p 53 $TARGET -oA $OUTPUT_DIR/07_dns_scripts

echo "[+] Escaneo completado. Generando reporte..."

# Generar reporte HTML
./generate_report.py $OUTPUT_DIR > $OUTPUT_DIR/report.html

echo "[+] Reporte disponible en: $OUTPUT_DIR/report.html"
```

### 11.4 Laboratorio 4: Automatizaci√≥n con Python

#### Framework de Reconocimiento Personalizado

```python
#!/usr/bin/env python3
# recon_framework.py

import subprocess
import requests
import json
import dns.resolver
import whois
import socket
from concurrent.futures import ThreadPoolExecutor
import argparse
import os
from datetime import datetime

class ReconFramework:
    def __init__(self, target, output_dir=None):
        self.target = target
        self.output_dir = output_dir or f"recon_{target}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        os.makedirs(self.output_dir, exist_ok=True)
        
    def log(self, message, level="INFO"):
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"[{timestamp}] [{level}] {message}")
        
    def save_results(self, filename, data):
        filepath = os.path.join(self.output_dir, filename)
        with open(filepath, 'w') as f:
            if isinstance(data, (dict, list)):
                json.dump(data, f, indent=2)
            else:
                f.write(str(data))
        self.log(f"Resultados guardados en {filepath}")
    
    def whois_lookup(self):
        """Informaci√≥n WHOIS del dominio"""
        self.log("Realizando consulta WHOIS...")
        try:
            w = whois.whois(self.target)
            whois_data = {
                'domain': w.domain,
                'registrar': w.registrar,
                'creation_date': str(w.creation_date),
                'expiration_date': str(w.expiration_date),
                'name_servers': w.name_servers
            }
            self.save_results('whois.json', whois_data)
            return whois_data
        except Exception as e:
            self.log(f"Error en WHOIS: {e}", "ERROR")
            return None
    
    def dns_enumeration(self):
        """Enumeraci√≥n de registros DNS"""
        self.log("Enumerando registros DNS...")
        dns_records = {}
        
        record_types = ['A', 'AAAA', 'CNAME', 'MX', 'NS', 'TXT', 'SOA']
        
        for record_type in record_types:
            try:
                answers = dns.resolver.resolve(self.target, record_type)
                dns_records[record_type] = [str(rdata) for rdata in answers]
            except:
                dns_records[record_type] = []
        
        self.save_results('dns_records.json', dns_records)
        return dns_records
    
    def subdomain_enumeration(self):
        """Enumeraci√≥n de subdominios usando m√∫ltiples herramientas"""
        self.log("Enumerando subdominios...")
        subdomains = set()
        
        # Subfinder
        try:
            result = subprocess.run(['subfinder', '-d', self.target, '-silent'], 
                                  capture_output=True, text=True, timeout=300)
            subdomains.update(result.stdout.strip().split('\n'))
        except:
            pass
        
        # Amass pasivo
        try:
            result = subprocess.run(['amass', 'enum', '-passive', '-d', self.target], 
                                  capture_output=True, text=True, timeout=300)
            subdomains.update(result.stdout.strip().split('\n'))
        except:
            pass
        
        # Limpiar resultados
        subdomains = [sub for sub in subdomains if sub and self.target in sub]
        
        self.save_results('subdomains.txt', '\n'.join(sorted(subdomains)))
        return list(subdomains)
    
    def port_scan(self, hosts=None):
        """Escaneo de puertos con Nmap"""
        self.log("Iniciando escaneo de puertos...")
        targets = hosts or [self.target]
        
        for host in targets:
            self.log(f"Escaneando {host}...")
            
            # Escaneo r√°pido
            cmd = ['nmap', '-sS', '-T4', '--top-ports', '1000', 
                   '-oA', f"{self.output_dir}/nmap_{host.replace('.', '_')}", host]
            
            try:
                subprocess.run(cmd, timeout=600)
            except subprocess.TimeoutExpired:
                self.log(f"Timeout en escaneo de {host}", "WARNING")
    
    def web_enumeration(self, urls):
        """Enumeraci√≥n web b√°sica"""
        self.log("Enumerando servicios web...")
        web_info = {}
        
        for url in urls:
            try:
                response = requests.get(f"http://{url}", timeout=10)
                web_info[url] = {
                    'status_code': response.status_code,
                    'headers': dict(response.headers),
                    'title': self.extract_title(response.text)
                }
            except:
                web_info[url] = {'error': 'No accesible'}
        
        self.save_results('web_info.json', web_info)
        return web_info
    
    def extract_title(self, html):
        """Extraer t√≠tulo de p√°gina HTML"""
        import re
        match = re.search(r'<title>(.*?)</title>', html, re.IGNORECASE)
        return match.group(1) if match else "Sin t√≠tulo"
    
    def run_full_recon(self):
        """Ejecutar reconocimiento completo"""
        self.log(f"Iniciando reconocimiento completo de {self.target}")
        
        # WHOIS
        whois_data = self.whois_lookup()
        
        # DNS
        dns_data = self.dns_enumeration()
        
        # Subdominios
        subdomains = self.subdomain_enumeration()
        
        # Escaneo de puertos
        all_hosts = [self.target] + subdomains[:10]  # Limitar a 10 subdominios
        self.port_scan(all_hosts)
        
        # Web enumeration
        web_hosts = [host for host in all_hosts if self.is_web_service(host)]
        if web_hosts:
            self.web_enumeration(web_hosts)
        
        self.generate_summary()
        self.log(f"Reconocimiento completado. Resultados en: {self.output_dir}")
    
    def is_web_service(self, host):
        """Verificar si el host tiene servicio web"""
        for port in [80, 443, 8080, 8443]:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(3)
                result = sock.connect_ex((host, port))
                sock.close()
                if result == 0:
                    return True
            except:
                pass
        return False
    
    def generate_summary(self):
        """Generar resumen de resultados"""
        summary = f"""
# Resumen de Reconocimiento - {self.target}
## Fecha: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

## Archivos generados:
"""
        for file in os.listdir(self.output_dir):
            summary += f"- {file}\n"
        
        self.save_results('summary.md', summary)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Framework de Reconocimiento')
    parser.add_argument('target', help='Dominio objetivo')
    parser.add_argument('-o', '--output', help='Directorio de salida')
    
    args = parser.parse_args()
    
    recon = ReconFramework(args.target, args.output)
    recon.run_full_recon()
```

### 11.5 Laboratorio 5: An√°lisis de Resultados

#### Herramienta de An√°lisis de Vulnerabilidades

```python
#!/usr/bin/env python3
# vuln_analyzer.py

import xml.etree.ElementTree as ET
import json
import csv
import argparse
from collections import defaultdict

class VulnAnalyzer:
    def __init__(self):
        self.vulnerabilities = []
        self.services = []
        self.hosts = []
    
    def parse_nmap_xml(self, xml_file):
        """Parsear archivo XML de Nmap"""
        tree = ET.parse(xml_file)
        root = tree.getroot()
        
        for host in root.findall('host'):
            host_info = {
                'ip': host.find('address').get('addr'),
                'ports': [],
                'os': None
            }
            
            # Informaci√≥n del OS
            os_elem = host.find('.//os/osmatch')
            if os_elem is not None:
                host_info['os'] = os_elem.get('name')
            
            # Puertos y servicios
            ports_elem = host.find('ports')
            if ports_elem is not None:
                for port in ports_elem.findall('port'):
                    port_info = {
                        'number': port.get('portid'),
                        'protocol': port.get('protocol'),
                        'state': port.find('state').get('state'),
                        'service': None,
                        'version': None
                    }
                    
                    service_elem = port.find('service')
                    if service_elem is not None:
                        port_info['service'] = service_elem.get('name')
                        port_info['version'] = service_elem.get('version')
                    
                    host_info['ports'].append(port_info)
            
            self.hosts.append(host_info)
    
    def identify_vulnerabilities(self):
        """Identificar posibles vulnerabilidades basadas en versiones"""
        vuln_db = {
            'apache': {
                '2.2.8': ['CVE-2009-3555', 'CVE-2010-0408'],
                '2.4.7': ['CVE-2014-0098', 'CVE-2014-0226']
            },
            'openssh': {
                '5.3': ['CVE-2010-4478'],
                '6.6': ['CVE-2016-0777', 'CVE-2016-0778']
            },
            'mysql': {
                '5.0': ['CVE-2012-2122'],
                '5.5.7': ['CVE-2012-0572']
            }
        }
        
        for host in self.hosts:
            for port in host['ports']:
                service = port.get('service', '').lower()
                version = port.get('version', '')
                
                if service in vuln_db:
                    for vuln_version, cves in vuln_db[service].items():
                        if vuln_version in version:
                            for cve in cves:
                                self.vulnerabilities.append({
                                    'host': host['ip'],
                                    'port': port['number'],
                                    'service': service,
                                    'version': version,
                                    'cve': cve,
                                    'severity': self.get_severity(cve)
                                })
    
    def get_severity(self, cve):
        """Obtener severidad de CVE (simplificado)"""
        # En implementaci√≥n real, consultar√≠a base de datos CVSS
        critical_cves = ['CVE-2014-0160', 'CVE-2017-0144']  # Ejemplos
        if cve in critical_cves:
            return 'Critical'
        return 'Medium'  # Por defecto
    
    def generate_report(self, output_format='json'):
        """Generar reporte de vulnerabilidades"""
        if output_format == 'json':
            return json.dumps({
                'hosts': self.hosts,
                'vulnerabilities': self.vulnerabilities,
                'summary': self.get_summary()
            }, indent=2)
        
        elif output_format == 'csv':
            output = []
            for vuln in self.vulnerabilities:
                output.append([
                    vuln['host'], vuln['port'], vuln['service'],
                    vuln['version'], vuln['cve'], vuln['severity']
                ])
            return output
    
    def get_summary(self):
        """Generar resumen de hallazgos"""
        severity_count = defaultdict(int)
        service_count = defaultdict(int)
        
        for vuln in self.vulnerabilities:
            severity_count[vuln['severity']] += 1
            service_count[vuln['service']] += 1
        
        return {
            'total_hosts': len(self.hosts),
            'total_vulnerabilities': len(self.vulnerabilities),
            'by_severity': dict(severity_count),
            'by_service': dict(service_count)
        }

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Analizador de Vulnerabilidades')
    parser.add_argument('xml_file', help='Archivo XML de Nmap')
    parser.add_argument('-f', '--format', choices=['json', 'csv'], 
                       default='json', help='Formato de salida')
    
    args = parser.parse_args()
    
    analyzer = VulnAnalyzer()
    analyzer.parse_nmap_xml(args.xml_file)
    analyzer.identify_vulnerabilities()
    
    report = analyzer.generate_report(args.format)
    
    if args.format == 'json':
        print(report)
    else:  # CSV
        writer = csv.writer(sys.stdout)
        writer.writerow(['Host', 'Port', 'Service', 'Version', 'CVE', 'Severity'])
        writer.writerows(report)
```

---

## 12. Casos de Estudio Reales

### 12.1 Caso de Estudio 1: Auditor√≠a de Red Corporativa

#### Escenario
Una empresa mediana (500 empleados) solicita auditor√≠a de su per√≠metro de red. Tienen presencia web, correo corporativo y acceso VPN.

#### Metodolog√≠a Aplicada

**Fase 1: Reconocimiento Pasivo (2 d√≠as)**
```bash
# Recopilaci√≥n inicial
Company: "TechCorp Solutions"
Domain: techcorp-solutions.com
IP Range: 203.0.113.0/24 (ejemplo)

# Informaci√≥n WHOIS
Registrar: GoDaddy
Created: 2015-03-15
Expires: 2025-03-15
Name Servers: ns1.techcorp-solutions.com, ns2.techcorp-solutions.com

# Subdominios identificados (25 encontrados)
- www.techcorp-solutions.com
- mail.techcorp-solutions.com
- vpn.techcorp-solutions.com
- ftp.techcorp-solutions.com
- dev.techcorp-solutions.com
- staging.techcorp-solutions.com
```

**Fase 2: Reconocimiento Activo (3 d√≠as)**
```bash
# Escaneo de red
nmap -sS -O -sV -p- 203.0.113.0/24

# Resultados principales:
203.0.113.10 - Web Server (Apache 2.4.41, PHP 7.4)
203.0.113.20 - Mail Server (Postfix, Dovecot)
203.0.113.30 - VPN Gateway (OpenVPN)
203.0.113.40 - FTP Server (vsftpd 3.0.2)
203.0.113.50 - Development Server (Nginx, Node.js)
```

#### Hallazgos Cr√≠ticos
1. **Servidor FTP con credenciales por defecto**
2. **Servidor de desarrollo accesible desde Internet**
3. **Versiones desactualizadas de Apache y PHP**
4. **Certificados SSL pr√≥ximos a expirar**

#### Recomendaciones
- Cambiar credenciales por defecto
- Mover servidor de desarrollo a red interna
- Actualizar software desactualizado
- Renovar certificados SSL

### 12.2 Caso de Estudio 2: E-commerce con Vulnerabilidades

#### Escenario
Tienda online que reporta actividad sospechosa. Se requiere evaluaci√≥n de seguridad urgente.

#### Descubrimientos durante Reconocimiento
```bash
# Tecnolog√≠as identificadas
- WordPress 5.2.4 (vulnerable)
- WooCommerce 3.8.1
- MySQL 5.7
- PHP 7.2

# Plugins vulnerables detectados
- Revolution Slider 5.4.8 (CVE-2020-11292)
- Contact Form 7 (versi√≥n desactualizada)

# Informaci√≥n sensible expuesta
- /wp-config.php.bak (archivo de backup)
- /debug.log (logs con informaci√≥n sensible)
- Directorio /uploads sin protecci√≥n
```

#### Vector de Ataque Identificado
1. Exploit en Revolution Slider ‚Üí Shell upload
2. Escalaci√≥n mediante MySQL UDF
3. Acceso a base de datos de clientes

### 12.3 Caso de Estudio 3: Infraestructura Cloud

#### Escenario
Startup que migr√≥ a AWS presenta configuraciones inseguras.

#### Hallazgos en Reconocimiento
```bash
# Buckets S3 p√∫blicos
aws s3 ls --no-sign-request s3://company-backups
aws s3 ls --no-sign-request s3://company-logs-2023

# Instancias EC2 expuestas
Instance i-0123456789abcdef0:
- Security Group: default (0.0.0.0/0:22)
- AMI: Ubuntu 18.04 (desactualizada)
- No MFA en usuarios IAM

# Bases de datos RDS
- Puerto 3306 abierto a 0.0.0.0/0
- Backups sin cifrar
- Credenciales en variables de entorno
```

---

## 13. Herramientas Emergentes y Tendencias

### 13.1 Herramientas de IA para Reconocimiento

#### GPT-powered OSINT
```python
# osint_gpt.py - Ejemplo conceptual
import openai

class OSINTAssistant:
    def __init__(self, api_key):
        self.client = openai.OpenAI(api_key=api_key)
    
    def analyze_company(self, company_name):
        prompt = f"""
        Act√∫a como un experto en OSINT. Para la empresa "{company_name}":
        1. Sugiere fuentes de informaci√≥n p√∫blica
        2. Identifica posibles subdominios
        3. Lista tecnolog√≠as probables
        4. Recomienda estrategias de reconocimiento
        
        Responde solo con informaci√≥n de fuentes p√∫blicas.
        """
        
        response = self.client.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}]
        )
        
        return response.choices[0].message.content
```

### 13.2 Automatizaci√≥n con APIs Modernas

#### Integration Framework
```python
# modern_recon.py
import asyncio
import aiohttp
from dataclasses import dataclass
from typing import List, Dict, Optional
import json

@dataclass
class ReconResult:
    source: str
    data: Dict
    timestamp: str

class ModernReconFramework:
    def __init__(self):
        self.results = []
        self.session = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def shodan_search(self, api_key: str, query: str):
        """B√∫squeda as√≠ncrona en Shodan"""
        url = f"https://api.shodan.io/shodan/host/search?key={api_key}&q={query}"
        async with self.session.get(url) as response:
            if response.status == 200:
                data = await response.json()
                return ReconResult("shodan", data, "2024")
    
    async def censys_search(self, api_id: str, api_secret: str, query: str):
        """B√∫squeda as√≠ncrona en Censys"""
        url = "https://search.censys.io/api/v2/hosts/search"
        auth = aiohttp.BasicAuth(api_id, api_secret)
        payload = {"q": query, "per_page": 100}
        
        async with self.session.get(url, auth=auth, params=payload) as response:
            if response.status == 200:
                data = await response.json()
                return ReconResult("censys", data, "2024")
    
    async def run_parallel_recon(self, target: str, configs: Dict):
        """Ejecutar reconocimiento paralelo"""
        tasks = []
        
        if "shodan" in configs:
            tasks.append(self.shodan_search(
                configs["shodan"]["api_key"], 
                f"hostname:{target}"
            ))
        
        if "censys" in configs:
            tasks.append(self.censys_search(
                configs["censys"]["api_id"],
                configs["censys"]["api_secret"],
                f"services.http.response.html_title: {target}"
            ))
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        self.results.extend([r for r in results if isinstance(r, ReconResult)])
        
        return self.results

# Uso del framework
async def main():
    configs = {
        "shodan": {"api_key": "YOUR_API_KEY"},
        "censys": {"api_id": "YOUR_ID", "api_secret": "YOUR_SECRET"}
    }
    
    async with ModernReconFramework() as recon:
        results = await recon.run_parallel_recon("example.com", configs)
        
        for result in results:
            print(f"Source: {result.source}")
            print(f"Data: {json.dumps(result.data, indent=2)[:200]}...")
            print("-" * 50)

# asyncio.run(main())
```

### 13.3 T√©cnicas Avanzadas de Evasi√≥n

#### Distributed Scanning
```bash
#!/bin/bash
# distributed_scan.sh

TARGET=$1
PROXY_LIST="proxies.txt"
OUTPUT_DIR="distributed_scan"

mkdir -p $OUTPUT_DIR

# Dividir rangos entre m√∫ltiples proxies
split_and_scan() {
    local proxy=$1
    local port_range=$2
    local target=$3
    
    # Configurar proxy para Nmap (requiere proxychains)
    echo "socks5 $proxy" > /tmp/proxychains_$.conf
    
    # Escaneo a trav√©s del proxy
    proxychains4 -f /tmp/proxychains_$.conf \
        nmap -sS -T2 -p $port_range $target \
        -oA $OUTPUT_DIR/scan_${proxy//./_}_$port_range
    
    rm /tmp/proxychains_$.conf
}

# Leer lista de proxies y distribuir trabajo
proxy_count=$(wc -l < $PROXY_LIST)
ports_per_proxy=$((65535 / proxy_count))

counter=1
while read proxy; do
    start_port=$((($counter - 1) * $ports_per_proxy + 1))
    end_port=$(($counter * $ports_per_proxy))
    
    if [ $counter -eq $proxy_count ]; then
        end_port=65535
    fi
    
    echo "[+] Escaneando puertos $start_port-$end_port via $proxy"
    split_and_scan $proxy $start_port-$end_port $TARGET &
    
    counter=$((counter + 1))
done < $PROXY_LIST

wait
echo "[+] Escaneo distribuido completado"
```

#### DNS over HTTPS (DoH) para Evasi√≥n
```python
#!/usr/bin/env python3
# doh_enum.py

import requests
import base64
import json
from concurrent.futures import ThreadPoolExecutor

class DoHResolver:
    def __init__(self):
        self.providers = [
            "https://cloudflare-dns.com/dns-query",
            "https://dns.google/dns-query",
            "https://dns.quad9.net/dns-query"
        ]
    
    def dns_query(self, domain, record_type="A", provider=None):
        """Realizar consulta DNS sobre HTTPS"""
        if not provider:
            provider = self.providers[0]
        
        headers = {
            "Accept": "application/dns-json",
            "User-Agent": "DoH-Client/1.0"
        }
        
        params = {
            "name": domain,
            "type": record_type
        }
        
        try:
            response = requests.get(provider, headers=headers, params=params)
            if response.status_code == 200:
                return response.json()
        except:
            return None
    
    def enumerate_subdomains_doh(self, domain, wordlist):
        """Enumerar subdominios usando DoH"""
        found_subdomains = []
        
        def check_subdomain(subdomain):
            full_domain = f"{subdomain}.{domain}"
            result = self.dns_query(full_domain)
            
            if result and result.get("Answer"):
                return full_domain
            return None
        
        # Usar ThreadPoolExecutor para paralelizaci√≥n
        with ThreadPoolExecutor(max_workers=20) as executor:
            results = list(executor.map(check_subdomain, wordlist))
        
        return [r for r in results if r]

# Ejemplo de uso
if __name__ == "__main__":
    resolver = DoHResolver()
    
    # Wordlist b√°sica
    wordlist = ["www", "mail", "ftp", "admin", "test", "dev", "api"]
    
    subdomains = resolver.enumerate_subdomains_doh("example.com", wordlist)
    
    for subdomain in subdomains:
        print(f"[+] Found: {subdomain}")
```

---

## 14. Integraci√≥n con Frameworks de Seguridad

### 14.1 Integraci√≥n con Metasploit

#### Importar Resultados de Nmap
```bash
# En consola de Metasploit
msfconsole

# Crear workspace
workspace -a recon_project

# Importar escaneo de Nmap
db_import /path/to/nmap_scan.xml

# Ver hosts importados
hosts

# Ver servicios
services

# Buscar exploits para servicios encontrados
search type:exploit platform:linux apache

# Usar auxiliary modules para m√°s reconocimiento
use auxiliary/scanner/http/http_version
set RHOSTS 192.168.1.100
run
```

#### Script de Automatizaci√≥n
```ruby
# auto_recon.rc - Script de Metasploit
# Uso: msfconsole -r auto_recon.rc

workspace -a auto_recon
setg RHOSTS 192.168.1.0/24

# HTTP enumeration
use auxiliary/scanner/http/http_version
run

use auxiliary/scanner/http/dir_scanner
set DICTIONARY /usr/share/metasploit-framework/data/wordlists/directory.txt
run

# SSH enumeration
use auxiliary/scanner/ssh/ssh_version
run

# SMB enumeration
use auxiliary/scanner/smb/smb_version
run

use auxiliary/scanner/smb/smb_enumshares
run

# Generate report
hosts -o /tmp/hosts.txt
services -o /tmp/services.txt
```

### 14.2 Integraci√≥n con OpenVAS/GVM

#### Automatizaci√≥n de Escaneos
```python
#!/usr/bin/env python3
# openvas_integration.py

from gvm.connections import UnixSocketConnection
from gvm.protocols.gmp import Gmp
from gvm.transforms import EtreeTransform
import time

class OpenVASManager:
    def __init__(self, socket_path="/var/run/gvmd.sock"):
        self.socket_path = socket_path
        self.gmp = None
    
    def connect(self, username, password):
        """Conectar a OpenVAS"""
        connection = UnixSocketConnection(path=self.socket_path)
        transform = EtreeTransform()
        
        self.gmp = Gmp(connection=connection, transform=transform)
        self.gmp.authenticate(username, password)
    
    def create_target(self, name, hosts):
        """Crear objetivo de escaneo"""
        response = self.gmp.create_target(
            name=name,
            hosts=[hosts]
        )
        return response.get('id')
    
    def create_and_start_scan(self, target_name, hosts, scan_config="Full and fast"):
        """Crear y iniciar escaneo"""
        # Crear objetivo
        target_id = self.create_target(target_name, hosts)
        
        # Obtener configuraci√≥n de escaneo
        configs = self.gmp.get_scan_configs()
        config_id = None
        
        for config in configs.xpath('config'):
            if scan_config in config.find('name').text:
                config_id = config.get('id')
                break
        
        if not config_id:
            raise ValueError(f"Configuraci√≥n '{scan_config}' no encontrada")
        
        # Crear tarea
        task_response = self.gmp.create_task(
            name=f"Scan_{target_name}",
            config_id=config_id,
            target_id=target_id
        )
        
        task_id = task_response.get('id')
        
        # Iniciar escaneo
        self.gmp.start_task(task_id)
        
        return task_id
    
    def wait_for_scan_completion(self, task_id):
        """Esperar a que termine el escaneo"""
        while True:
            task = self.gmp.get_task(task_id)
            status = task.find('status').text
            
            print(f"Estado del escaneo: {status}")
            
            if status == "Done":
                break
            elif status in ["Stopped", "Interrupted"]:
                raise Exception(f"Escaneo termin√≥ con estado: {status}")
            
            time.sleep(30)
    
    def get_scan_results(self, task_id, format="XML"):
        """Obtener resultados del escaneo"""
        # Obtener ID del reporte
        reports = self.gmp.get_reports(task_id=task_id)
        report_id = reports.xpath('report/@id')[0]
        
        # Descargar reporte
        response = self.gmp.get_report(
            report_id=report_id,
            report_format_id="a994b278-1f62-11e1-96ac-406186ea4fc5"  # XML format
        )
        
        return response

# Ejemplo de uso
if __name__ == "__main__":
    scanner = OpenVASManager()
    scanner.connect("admin", "password")
    
    # Crear y iniciar escaneo
    task_id = scanner.create_and_start_scan("Test Target", "192.168.1.100")
    
    # Esperar resultados
    scanner.wait_for_scan_completion(task_id)
    
    # Obtener resultados
    results = scanner.get_scan_results(task_id)
    
    # Guardar resultados
    with open("openvas_results.xml", "w") as f:
        f.write(results)
```

### 14.3 SIEM Integration

#### Script para Splunk
```python
#!/usr/bin/env python3
# splunk_logger.py

import requests
import json
import time
from datetime import datetime

class SplunkLogger:
    def __init__(self, splunk_host, hec_token, index="security"):
        self.splunk_host = splunk_host
        self.hec_token = hec_token
        self.index = index
        self.hec_url = f"https://{splunk_host}:8088/services/collector/event"
    
    def log_recon_event(self, event_type, source_ip, target, details):
        """Registrar evento de reconocimiento en Splunk"""
        event = {
            "time": int(time.time()),
            "host": source_ip,
            "source": "recon_framework",
            "sourcetype": "recon:event",
            "index": self.index,
            "event": {
                "event_type": event_type,
                "source_ip": source_ip,
                "target": target,
                "details": details,
                "timestamp": datetime.now().isoformat()
            }
        }
        
        headers = {
            "Authorization": f"Splunk {self.hec_token}",
            "Content-Type": "application/json"
        }
        
        try:
            response = requests.post(
                self.hec_url,
                data=json.dumps(event),
                headers=headers,
                verify=False
            )
            
            if response.status_code == 200:
                print(f"[+] Evento enviado a Splunk: {event_type}")
            else:
                print(f"[-] Error enviando evento: {response.status_code}")
        
        except Exception as e:
            print(f"[-] Error: {e}")

# Ejemplo de uso integrado con reconocimiento
def recon_with_logging():
    logger = SplunkLogger("splunk.empresa.com", "YOUR-HEC-TOKEN")
    
    # Simular eventos de reconocimiento
    targets = ["example.com", "test.example.com", "mail.example.com"]
    
    for target in targets:
        # Log inicio de escaneo
        logger.log_recon_event(
            "port_scan_start",
            "10.0.0.50",  # IP del scanner
            target,
            {"scan_type": "tcp", "ports": "1-1000"}
        )
        
        # Simular resultados
        open_ports = [22, 80, 443]
        for port in open_ports:
            logger.log_recon_event(
                "open_port_found",
                "10.0.0.50",
                target,
                {"port": port, "protocol": "tcp", "state": "open"}
            )
        
        # Log fin de escaneo
        logger.log_recon_event(
            "port_scan_complete",
            "10.0.0.50",
            target,
            {"total_ports_scanned": 1000, "open_ports": len(open_ports)}
        )

if __name__ == "__main__":
    recon_with_logging()
```

---

## 15. Laboratorio Final: Proyecto Integrador

### 15.1 Especificaciones del Proyecto

#### Objetivo
Desarrollar una herramienta completa de reconocimiento que integre m√∫ltiples fuentes de informaci√≥n y genere reportes profesionales.

#### Requisitos Funcionales
1. **Reconocimiento pasivo automatizado**
2. **Escaneo activo con m√∫ltiples herramientas**
3. **An√°lisis de vulnerabilidades**
4. **Generaci√≥n de reportes HTML/PDF**
5. **Integraci√≥n con APIs de threat intelligence**
6. **Logging y auditabilidad**

#### Arquitectura del Sistema
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Web Interface ‚îÇ    ‚îÇ  Core Engine    ‚îÇ    ‚îÇ   Data Storage  ‚îÇ
‚îÇ   (Flask/Django)‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ   (Python)      ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ   (SQLite/JSON) ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                              ‚îÇ
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ         ‚îÇ         ‚îÇ
            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
            ‚îÇ Passive   ‚îÇ ‚îÇ Active ‚îÇ ‚îÇ Report ‚îÇ
            ‚îÇ Recon     ‚îÇ ‚îÇ Recon  ‚îÇ ‚îÇ Engine ‚îÇ
            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 15.2 Implementaci√≥n del Core Engine

```python
#!/usr/bin/env python3
# recon_platform.py

import asyncio
import sqlite3
import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional
import uuid

class ReconPlatform:
    def __init__(self, db_path="recon.db"):
        self.db_path = db_path
        self.logger = self.setup_logging()
        self.init_database()
    
    def setup_logging(self):
        """Configurar logging"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('recon.log'),
                logging.StreamHandler()
            ]
        )
        return logging.getLogger('ReconPlatform')
    
    def init_database(self):
        """Inicializar base de datos"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Tabla de proyectos
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS projects (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                target TEXT NOT NULL,
                created_at TIMESTAMP,
                status TEXT DEFAULT 'active'
            )
        ''')
        
        # Tabla de resultados
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS results (
                id TEXT PRIMARY KEY,
                project_id TEXT,
                module TEXT NOT NULL,
                result_type TEXT NOT NULL,
                data JSON,
                created_at TIMESTAMP,
                FOREIGN KEY (project_id) REFERENCES projects (id)
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def create_project(self, name: str, target: str) -> str:
        """Crear nuevo proyecto"""
        project_id = str(uuid.uuid4())
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO projects (id, name, target, created_at)
            VALUES (?, ?, ?, ?)
        ''', (project_id, name, target, datetime.now()))
        
        conn.commit()
        conn.close()
        
        self.logger.info(f"Proyecto creado: {name} ({project_id})")
        return project_id
    
    def save_result(self, project_id: str, module: str, result_type: str, data: Dict):
        """Guardar resultado en base de datos"""
        result_id = str(uuid.uuid4())
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO results (id, project_id, module, result_type, data, created_at)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (result_id, project_id, module, result_type, json.dumps(data), datetime.now()))
        
        conn.commit()
        conn.close()
    
    async def run_reconnaissance(self, project_id: str, target: str, modules: List[str]):
        """Ejecutar reconocimiento completo"""
        self.logger.info(f"Iniciando reconocimiento de {target}")
        
        # M√≥dulos disponibles
        available_modules = {
            'whois': self.whois_module,
            'dns': self.dns_module,
            'subdomain': self.subdomain_module,
            'portscan': self.portscan_module,
            'web': self.web_module
        }
        
        # Ejecutar m√≥dulos seleccionados
        for module_name in modules:
            if module_name in available_modules:
                self.logger.info(f"Ejecutando m√≥dulo: {module_name}")
                try:
                    result = await available_modules[module_name](target)
                    self.save_result(project_id, module_name, 'scan_result', result)
                except Exception as e:
                    self.logger.error(f"Error en m√≥dulo {module_name}: {e}")
    
    async def whois_module(self, target: str) -> Dict:
        """M√≥dulo de informaci√≥n WHOIS"""
        # Implementaci√≥n simplificada
        return {
            'domain': target,
            'registrar': 'Example Registrar',
            'created': '2020-01-01',
            'expires': '2025-01-01'
        }
    
    async def dns_module(self, target: str) -> Dict:
        """M√≥dulo de enumeraci√≥n DNS"""
        # Implementaci√≥n simplificada
        return {
            'a_records': ['203.0.113.1'],
            'mx_records': ['mail.example.com'],
            'ns_records': ['ns1.example.com', 'ns2.example.com']
        }
    
    async def subdomain_module(self, target: str) -> Dict:
        """M√≥dulo de enumeraci√≥n de subdominios"""
        # Implementaci√≥n usando herramientas reales
        import subprocess
        
        try:
            # Usar subfinder
            result = subprocess.run(
                ['subfinder', '-d', target, '-silent'],
                capture_output=True, text=True, timeout=300
            )
            
            subdomains = [sub.strip() for sub in result.stdout.split('\n') if sub.strip()]
            
            return {
                'subdomains': subdomains,
                'count': len(subdomains),
                'tool': 'subfinder'
            }
        except Exception as e:
            self.logger.error(f"Error en enumeraci√≥n de subdominios: {e}")
            return {'error': str(e)}
    
    async def portscan_module(self, target: str) -> Dict:
        """M√≥dulo de escaneo de puertos"""
        import subprocess
        
        try:
            # Usar nmap
            result = subprocess.run([
                'nmap', '-sS', '-T4', '--top-ports', '1000',
                '-oX', '/tmp/nmap_temp.xml', target
            ], capture_output=True, text=True, timeout=600)
            
            # Parse XML result (simplificado)
            return {
                'command': f"nmap -sS -T4 --top-ports 1000 {target}",
                'exit_code': result.returncode,
                'xml_file': '/tmp/nmap_temp.xml'
            }
        except Exception as e:
            return {'error': str(e)}
    
    async def web_module(self, target: str) -> Dict:
        """M√≥dulo de enumeraci√≥n web"""
        import aiohttp
        
        results = {}
        protocols = ['http', 'https']
        
        async with aiohttp.ClientSession() as session:
            for protocol in protocols:
                try:
                    url = f"{protocol}://{target}"
                    async with session.get(url, timeout=10) as response:
                        results[protocol] = {
                            'status': response.status,
                            'headers': dict(response.headers),
                            'url': str(response.url)
                        }
                except Exception as e:
                    results[protocol] = {'error': str(e)}
        
        return results
    
    def generate_report(self, project_id: str, format='html') -> str:
        """Generar reporte de proyecto"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Obtener informaci√≥n del proyecto
        cursor.execute('SELECT * FROM projects WHERE id = ?', (project_id,))
        project = cursor.fetchone()
        
        # Obtener resultados
        cursor.execute('''
            SELECT module, result_type, data, created_at 
            FROM results WHERE project_id = ?
            ORDER BY created_at
        ''', (project_id,))
        results = cursor.fetchall()
        
        conn.close()
        
        if format == 'html':
            return self.generate_html_report(project, results)
        elif format == 'json':
            return self.generate_json_report(project, results)
    
    def generate_html_report(self, project, results) -> str:
        """Generar reporte HTML"""
        html_template = '''
        <!DOCTYPE html>
        <html>
        <head>
            <title>Recon Report - {project_name}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 40px; }}
                .header {{ background: #2c3e50; color: white; padding: 20px; }}
                .section {{ margin: 20px 0; padding: 15px; border-left: 4px solid #3498db; }}
                .result {{ background: #f8f9fa; padding: 10px; margin: 10px 0; border-radius: 5px; }}
                pre {{ background: #2c3e50; color: #ecf0f1; padding: 10px; overflow-x: auto; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Reconnaissance Report</h1>
                <p>Target: {target}</p>
                <p>Generated: {timestamp}</p>
            </div>
            
            {results_html}
        </body>
        </html>
        '''
        
        results_html = ""
        for result in results:
            module, result_type, data, created_at = result
            results_html += f'''
            <div class="section">
                <h2>{module.capitalize()} Results</h2>
                <div class="result">
                    <strong>Type:</strong> {result_type}<br>
                    <strong>Timestamp:</strong> {created_at}<br>
                    <pre>{json.dumps(json.loads(data), indent=2)}</pre>
                </div>
            </div>
            '''
        
        return html_template.format(
            project_name=project[1],
            target=project[2],
            timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            results_html=results_html
        )

# CLI Interface
class ReconCLI:
    def __init__(self):
        self.platform = ReconPlatform()
    
    async def run_scan(self, target: str, modules: List[str], project_name: str = None):
        """Ejecutar escaneo desde CLI"""
        if not project_name:
            project_name = f"Scan_{target}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        project_id = self.platform.create_project(project_name, target)
        await self.platform.run_reconnaissance(project_id, target, modules)
        
        # Generar reporte
        report_file = f"report_{project_id}.html"
        html_report = self.platform.generate_report(project_id, 'html')
        
        with open(report_file, 'w') as f:
            f.write(html_report)
        
        print(f"[+] Reconocimiento completado")
        print(f"[+] Reporte generado: {report_file}")

if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description='Plataforma de Reconocimiento')
    parser.add_argument('target', help='Objetivo del reconocimiento')
    parser.add_argument('-m', '--modules', nargs='+', 
                       choices=['whois', 'dns', 'subdomain', 'portscan', 'web'],
                       default=['whois', 'dns', 'subdomain', 'portscan', 'web'],
                       help='M√≥dulos a ejecutar')
    parser.add_argument('-n', '--name', help='Nombre del proyecto')
    
    args = parser.parse_args()
    
    cli = ReconCLI()
    asyncio.run(cli.run_scan(args.target, args.modules, args.name))
```

### 15.3 Interfaz Web con Flask

```python
#!/usr/bin/env python3
# web_interface.py

from flask import Flask, render_template, request, jsonify, send_file
import asyncio
from recon_platform import ReconPlatform
import json
from datetime import datetime

app = Flask(__name__)
platform = ReconPlatform()

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/api/scan', methods=['POST'])
def start_scan():
    data = request.get_json()
    target = data.get('target')
    modules = data.get('modules', ['whois', 'dns'])
    project_name = data.get('project_name', f"Web_Scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}")
    
    # Crear proyecto
    project_id = platform.create_project(project_name, target)
    
    # Ejecutar escaneo en background (simplificado)
    # En producci√≥n, usar Celery o similar
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.run_until_complete(platform.run_reconnaissance(project_id, target, modules))
    
    return jsonify({
        'status': 'completed',
        'project_id': project_id,
        'message': 'Scan completed successfully'
    })

@app.route('/api/projects')
def get_projects():
    conn = platform.get_connection()
    cursor = conn.cursor()
    
    cursor.execute('SELECT * FROM projects ORDER BY created_at DESC')
    projects = cursor.fetchall()
    
    conn.close()
    
    return jsonify([{
        'id': p[0],
        'name': p[1],
        'target': p[2],
        'created_at': p[3],
        'status': p[4]