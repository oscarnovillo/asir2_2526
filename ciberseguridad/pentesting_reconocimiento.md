# Fase de Reconocimiento en Pentesting
## ASIR2 - Ciberseguridad

---

## Índice
1. [Introducción al Reconocimiento](#introducción-al-reconocimiento)
2. [Tipos de Reconocimiento](#tipos-de-reconocimiento)
3. [Herramientas de Reconocimiento Web](#herramientas-de-reconocimiento-web)
4. [Reconocimiento de Dominios y Subdominios](#reconocimiento-de-dominios-y-subdominios)
5. [Búsqueda de Información Corporativa](#búsqueda-de-información-corporativa)
6. [Escaneo de Puertos con Nmap](#escaneo-de-puertos-con-nmap)
7. [Alternativas a Nmap](#alternativas-a-nmap)
8. [Metodología y Buenas Prácticas](#metodología-y-buenas-prácticas)
9. [Ejercicios Prácticos](#ejercicios-prácticos)
10. [Recursos Adicionales](#recursos-adicionales)

---

## 1. Introducción al Reconocimiento

### ¿Qué es la Fase de Reconocimiento?

La fase de reconocimiento es la **primera y más crítica etapa** de un test de penetración. Durante esta fase, el pentester recopila toda la información posible sobre el objetivo sin interactuar directamente con sus sistemas.

### Objetivos Principales

- **Mapear la superficie de ataque** del objetivo
- **Identificar tecnologías** utilizadas
- **Descubrir subdominios** y servicios expuestos
- **Recopilar información** sobre empleados y estructura organizacional
- **Encontrar posibles vectores** de ataque inicial

### Marco Legal y Ético

⚠️ **IMPORTANTE**: Todas las técnicas mostradas deben utilizarse únicamente en:
- Sistemas propios
- Entornos de laboratorio
- Auditorías autorizadas por escrito
- Plataformas de práctica legales (HackTheBox, TryHackMe, etc.)

---

## 2. Tipos de Reconocimiento

### 2.1 Reconocimiento Pasivo

**Definición**: Recopilación de información sin interactuar directamente con el objetivo.

**Características**:
- No genera logs en el objetivo
- Menor riesgo de detección
- Utiliza fuentes públicas de información

**Fuentes comunes**:
- Motores de búsqueda
- Redes sociales
- Bases de datos públicas
- Servicios de inteligencia de amenazas

### 2.2 Reconocimiento Activo

**Definición**: Interacción directa con los sistemas del objetivo.

**Características**:
- Genera logs y tráfico detectable
- Proporciona información más precisa
- Mayor riesgo de detección

**Técnicas comunes**:
- Escaneo de puertos
- Enumeración de servicios
- Pruebas de conectividad

---

## 3. Herramientas de Reconocimiento Web

### 3.1 Shodan

**Descripción**: Motor de búsqueda para dispositivos conectados a Internet.

**Características principales**:
- Indexa millones de dispositivos IoT
- Información sobre puertos abiertos
- Banners de servicios
- Geolocalización de dispositivos

**Sintaxis básica de búsqueda**:

```bash
# Búsqueda por IP
ip:192.168.1.1

# Búsqueda por puerto
port:22

# Búsqueda por servicio
apache

# Búsqueda por país
country:ES

# Búsqueda por organización
org:"Telefonica"

# Combinaciones
apache country:ES port:443

# Búsqueda de cámaras web
title:"webcam" country:ES

# Servidores con vulnerabilidades específicas
vuln:CVE-2014-0160
```

**Comandos útiles**:
```bash
# Instalación de Shodan CLI
pip install shodan

# Configurar API key
shodan init YOUR_API_KEY

# Búsqueda básica
shodan search apache

# Información de una IP específica
shodan host 8.8.8.8

# Descargar resultados
shodan download resultados apache country:ES
```

### 3.2 Censys

**Descripción**: Plataforma de inteligencia de Internet que escanea y indexa dispositivos públicos.

**Ventajas sobre Shodan**:
- Datos más actualizados
- Mejor análisis de certificados SSL
- Interfaz más intuitiva para principiantes

**Consultas útiles**:
```bash
# Búsqueda por dominio
services.http.response.html_title: "Apache"

# Certificados SSL
certificates.leaf_data.subject.common_name: "*.example.com"

# Servicios específicos
services.service_name: SSH and location.country: Spain

# Puertos abiertos
services.port: 3389 and location.country_code: ES
```

### 3.3 Google Dorking

**Técnica**: Uso de operadores avanzados en Google para encontrar información específica.

**Operadores esenciales**:
```bash
# Búsqueda en sitio específico
site:ejemplo.com

# Tipo de archivo específico
filetype:pdf site:ejemplo.com

# Texto en URL
inurl:admin

# Texto en título
intitle:"index of"

# Texto específico en página
intext:"password"

# Páginas similares
related:ejemplo.com

# Cache de Google
cache:ejemplo.com

# Información del sitio
info:ejemplo.com
```

**Dorks útiles para pentesting**:
```bash
# Archivos de configuración
filetype:conf inurl:conf

# Bases de datos expuestas
filetype:sql

# Documentos con información sensible
filetype:xls site:ejemplo.com "confidential"

# Paneles de administración
inurl:admin intitle:login

# Archivos de backup
filetype:bak site:ejemplo.com

# Directorios listables
intitle:"index of" site:ejemplo.com
```

---

## 4. Reconocimiento de Dominios y Subdominios

### 4.1 Información WHOIS

**Herramientas**:
```bash
# Comando whois tradicional
whois ejemplo.com

# Online: whois.net, whois.com
```

**Información obtenible**:
- Registrador del dominio
- Fechas de registro y expiración
- Servidores DNS
- Información de contacto (si no está protegida)
- Historial de cambios

### 4.2 Enumeración de Subdominios

#### 4.2.1 Subfinder
```bash
# Instalación
go install -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest

# Uso básico
subfinder -d ejemplo.com

# Guardar resultados
subfinder -d ejemplo.com -o subdominios.txt

# Usar múltiples fuentes
subfinder -d ejemplo.com -all
```

#### 4.2.2 Amass
```bash
# Instalación
sudo apt install amass

# Enumeración pasiva
amass enum -passive -d ejemplo.com

# Enumeración activa
amass enum -active -d ejemplo.com

# Con resolución DNS
amass enum -active -d ejemplo.com -r 8.8.8.8,1.1.1.1
```

#### 4.2.3 Sublist3r
```bash
# Instalación
git clone https://github.com/aboul3la/Sublist3r.git
cd Sublist3r
pip install -r requirements.txt

# Uso básico
python sublist3r.py -d ejemplo.com

# Con bruteforce
python sublist3r.py -d ejemplo.com -b

# Especificar threads
python sublist3r.py -d ejemplo.com -t 100
```

#### 4.2.4 Gobuster (DNS)
```bash
# Instalación
sudo apt install gobuster

# Enumeración de subdominios
gobuster dns -d ejemplo.com -w /usr/share/wordlists/SecLists/Discovery/DNS/subdomains-top1million-5000.txt

# Con múltiples threads
gobuster dns -d ejemplo.com -w wordlist.txt -t 50
```

### 4.3 Análisis de DNS

#### 4.3.1 Registros DNS importantes
```bash
# Registro A (IPv4)
dig A ejemplo.com

# Registro AAAA (IPv6)
dig AAAA ejemplo.com

# Registro MX (Mail Exchange)
dig MX ejemplo.com

# Registro TXT (información adicional)
dig TXT ejemplo.com

# Registro NS (Name Servers)
dig NS ejemplo.com

# Registro CNAME (Alias)
dig CNAME www.ejemplo.com

# Todos los registros
dig ANY ejemplo.com
```

#### 4.3.2 Transferencia de zona DNS
```bash
# Intentar transferencia de zona
dig axfr ejemplo.com @ns1.ejemplo.com

# Con nslookup
nslookup
> set type=any
> ls -d ejemplo.com
```

#### 4.3.3 DNS Reverse Lookup
```bash
# Lookup inverso
dig -x 192.168.1.1

# Con nslookup
nslookup 192.168.1.1
```

---

## 5. Búsqueda de Información Corporativa

### 5.1 Búsqueda de Empleados

#### 5.1.1 LinkedIn
- **Búsqueda manual**: Utilizar filtros avanzados
- **Herramientas automatizadas**: 
  - LinkedIn2Username
  - CrossLinked

```bash
# CrossLinked - Búsqueda de empleados en LinkedIn
python3 crosslinked.py -f "full_names.txt" "CompanyName"

# LinkedIn2Username - Generar usuarios potenciales
python linkedin2username.py "Company Name"
```

#### 5.1.2 Hunter.io
```bash
# Búsqueda de emails por dominio
# Via web: hunter.io

# Patrones comunes de email:
# nombre.apellido@empresa.com
# n.apellido@empresa.com
# nombre@empresa.com
# napellido@empresa.com
```

#### 5.1.3 theHarvester
```bash
# Instalación
sudo apt install theharvester

# Búsqueda de emails
theharvester -d ejemplo.com -b google

# Múltiples fuentes
theharvester -d ejemplo.com -b google,bing,yahoo

# Limitar resultados
theharvester -d ejemplo.com -l 100 -b google

# Guardar resultados
theharvester -d ejemplo.com -b all -f resultados.html
```

### 5.2 Información en Redes Sociales

#### Herramientas OSINT
```bash
# Sherlock - Buscar usernames en redes sociales
python3 sherlock usuario

# Social-Analyzer - Análisis de perfiles sociales
python3 social-analyzer.py --username "john_doe"

# Twint - Análisis de Twitter
twint -u username --email
```

### 5.3 Documentos y Metadatos

#### 5.3.1 FOCA (Windows)
- Búsqueda automática de documentos
- Extracción de metadatos
- Análisis de información sensible

#### 5.3.2 Metagoofil
```bash
# Instalación
git clone https://github.com/laramies/metagoofil.git

# Búsqueda de documentos PDF
python3 metagoofil.py -d ejemplo.com -t pdf -l 100

# Múltiples tipos de archivo
python3 metagoofil.py -d ejemplo.com -t pdf,doc,xls,ppt -l 200
```

#### 5.3.3 ExifTool
```bash
# Análisis de metadatos de archivos
exiftool documento.pdf
exiftool imagen.jpg

# Eliminar metadatos
exiftool -all= archivo.jpg
```

---

## 6. Escaneo de Puertos con Nmap

### 6.1 Conceptos Básicos

**Estados de puertos en Nmap**:
- **Open**: Puerto abierto y servicio respondiendo
- **Closed**: Puerto cerrado pero accesible
- **Filtered**: Puerto filtrado por firewall
- **Unfiltered**: Puerto accesible pero estado indeterminado
- **Open|Filtered**: No se puede determinar si está abierto o filtrado
- **Closed|Filtered**: No se puede determinar si está cerrado o filtrado

### 6.2 Sintaxis Básica

```bash
# Escaneo básico
nmap ejemplo.com

# Especificar puertos
nmap -p 80,443 ejemplo.com

# Rango de puertos
nmap -p 1-1000 ejemplo.com

# Todos los puertos
nmap -p- ejemplo.com

# Puertos más comunes
nmap --top-ports 100 ejemplo.com
```

### 6.3 Tipos de Escaneo

#### 6.3.1 Escaneo TCP
```bash
# TCP SYN scan (por defecto con privilegios)
nmap -sS ejemplo.com

# TCP Connect scan (sin privilegios)
nmap -sT ejemplo.com

# TCP ACK scan (detección de firewalls)
nmap -sA ejemplo.com

# TCP Window scan
nmap -sW ejemplo.com

# TCP FIN scan (evasión)
nmap -sF ejemplo.com

# TCP Null scan (evasión)
nmap -sN ejemplo.com

# TCP Xmas scan (evasión)
nmap -sX ejemplo.com
```

#### 6.3.2 Escaneo UDP
```bash
# UDP scan (lento pero importante)
nmap -sU ejemplo.com

# UDP en puertos específicos
nmap -sU -p 53,161,162 ejemplo.com

# Combinado TCP y UDP
nmap -sS -sU -p T:80,443,U:53,161 ejemplo.com
```

### 6.4 Detección de Servicios y Versiones

```bash
# Detección de servicios
nmap -sV ejemplo.com

# Detección de SO
nmap -O ejemplo.com

# Detección agresiva (OS + servicios + scripts)
nmap -A ejemplo.com

# Intensidad de detección
nmap -sV --version-intensity 9 ejemplo.com

# Solo detección de servicios sin ping
nmap -sV -Pn ejemplo.com
```

### 6.5 Scripts de Nmap (NSE)

```bash
# Listar categorías de scripts
nmap --script-help

# Scripts por defecto
nmap -sC ejemplo.com

# Scripts de vulnerabilidades
nmap --script vuln ejemplo.com

# Scripts específicos
nmap --script http-title,http-headers ejemplo.com

# Scripts de fuerza bruta
nmap --script brute ejemplo.com

# Scripts de enumeración
nmap --script enum ejemplo.com

# Script específico para HTTP
nmap --script http-enum ejemplo.com

# Actualizar base de datos de scripts
nmap --script-updatedb
```

### 6.6 Técnicas de Evasión

```bash
# Fragmentar paquetes
nmap -f ejemplo.com

# Fragmentar con MTU específico
nmap --mtu 24 ejemplo.com

# Usar señuelos
nmap -D RND:10 ejemplo.com

# IP de origen falsa
nmap -S 192.168.1.5 ejemplo.com

# Interfaz específica
nmap -e eth0 ejemplo.com

# Timing (de 0 paranoid a 5 insane)
nmap -T4 ejemplo.com

# Delays personalizados
nmap --scan-delay 1s ejemplo.com

# Randomizar orden de hosts
nmap --randomize-hosts 192.168.1.0/24
```

### 6.7 Salida y Logging

```bash
# Salida normal
nmap -oN scan.txt ejemplo.com

# Salida XML
nmap -oX scan.xml ejemplo.com

# Salida greppable
nmap -oG scan.grep ejemplo.com

# Todas las salidas
nmap -oA scan ejemplo.com

# Salida a stdout y archivo
nmap ejemplo.com | tee scan.txt

# Verbosidad
nmap -v ejemplo.com
nmap -vv ejemplo.com
```

### 6.8 Ejemplos Prácticos

```bash
# Escaneo completo de red local
nmap -sS -O -sV -A 192.168.1.0/24

# Escaneo rápido de puertos comunes
nmap -F -T4 ejemplo.com

# Escaneo sigiloso
nmap -sS -T2 -f ejemplo.com

# Descubrimiento de hosts activos
nmap -sn 192.168.1.0/24

# Escaneo de servicios web
nmap -p 80,443,8080,8443 --script http-title,http-headers ejemplo.com

# Búsqueda de vulnerabilidades específicas
nmap -p 445 --script smb-vuln-* ejemplo.com
```

---

## 7. Alternativas a Nmap

### 7.1 Masscan

**Características**:
- Extremadamente rápido
- Capaz de escanear toda Internet
- Limitado en detección de servicios

```bash
# Instalación
sudo apt install masscan

# Escaneo básico
masscan -p80,443 192.168.1.0/24

# Escaneo rápido de red grande
masscan -p1-65535 10.0.0.0/8 --rate=1000

# Guardar resultados
masscan -p80,443 192.168.1.0/24 -oX scan.xml

# Configuración avanzada
masscan -p80,443 --rate=1000 --router-ip 192.168.1.1 192.168.1.0/24
```

### 7.2 Zmap

**Características**:
- Diseñado para escaneos de Internet completa
- Muy eficiente para escaneos de un solo puerto

```bash
# Instalación
sudo apt install zmap

# Escaneo de puerto específico en red grande
zmap -p 80 10.0.0.0/8

# Con salida específica
zmap -p 443 192.168.1.0/24 -o resultados.txt

# Escaneo con rate limiting
zmap -p 22 10.0.0.0/16 -r 1000
```

### 7.3 RustScan

**Características**:
- Escrito en Rust (muy rápido)
- Integración con Nmap
- Interfaz moderna

```bash
# Instalación
cargo install rustscan

# O con apt en algunas distribuciones
sudo apt install rustscan

# Escaneo básico (usa todos los puertos)
rustscan -a ejemplo.com

# Escaneo con Nmap integration
rustscan -a ejemplo.com -- -sC -sV

# Escaneo de rango
rustscan -a 192.168.1.0/24

# Especificar puertos
rustscan -a ejemplo.com -p 80,443,22
```

### 7.4 Unicornscan

**Características**:
- Escaneo asíncrono
- Bueno para evasión
- Menos mantenido actualmente

```bash
# Instalación
sudo apt install unicornscan

# Escaneo TCP
unicornscan -mT ejemplo.com:1-1000

# Escaneo UDP
unicornscan -mU ejemplo.com:1-1000

# Con rate limiting
unicornscan -r 300 -mT ejemplo.com:1-65535
```

### 7.5 Hping3

**Características**:
- Generador de paquetes personalizado
- Útil para pruebas específicas
- Capacidades de firewall testing

```bash
# Instalación
sudo apt install hping3

# Ping TCP a puerto específico
hping3 -S -p 80 ejemplo.com

# Escaneo de puertos TCP
hping3 -S --scan 1-1000 ejemplo.com

# Test de firewall
hping3 -A -p 80 ejemplo.com

# Fragmentación
hping3 -S -p 80 -f ejemplo.com
```

---

## 8. Metodología y Buenas Prácticas

### 8.1 Proceso Estructurado

#### Fase 1: Recopilación Pasiva
1. **Búsqueda OSINT inicial**
   - Google Dorking
   - Shodan/Censys
   - Información corporativa

2. **Análisis de dominios**
   - WHOIS
   - DNS records
   - Subdominios

3. **Recopilación de contactos**
   - Empleados
   - Emails
   - Estructura organizacional

#### Fase 2: Recopilación Activa
1. **Descubrimiento de hosts**
   - Ping sweeps
   - ARP scanning (redes locales)

2. **Escaneo de puertos**
   - Puertos comunes primero
   - Escaneo completo después
   - UDP en servicios críticos

3. **Enumeración de servicios**
   - Detección de versiones
   - Banner grabbing
   - Scripts especializados

### 8.2 Documentación

**Template de informe de reconocimiento**:
```markdown
# Informe de Reconocimiento - [Objetivo]
## Fecha: [Fecha]
## Auditor: [Nombre]

### 1. Información del Dominio
- **Dominio principal**: 
- **Registrador**: 
- **Fecha de registro**: 
- **Servidores DNS**: 

### 2. Subdominios Encontrados
- subdominio1.ejemplo.com (IP: X.X.X.X)
- subdominio2.ejemplo.com (IP: Y.Y.Y.Y)

### 3. Servicios Identificados
| IP | Puerto | Servicio | Versión |
|----|--------|----------|---------|
| X.X.X.X | 80 | HTTP | Apache 2.4.41 |
| X.X.X.X | 443 | HTTPS | Apache 2.4.41 |

### 4. Información de Contactos
- **Emails encontrados**: 
- **Empleados identificados**: 

### 5. Posibles Vectores de Ataque
- [ ] Servicios desactualizados
- [ ] Puertos innecesarios abiertos
- [ ] Información sensible expuesta

### 6. Recomendaciones
1. Cerrar puertos innecesarios
2. Actualizar servicios desactualizados
3. Implementar rate limiting
```

### 8.3 Consideraciones Legales y Éticas

#### ✅ Actividades Permitidas
- Reconocimiento en sistemas propios
- Uso de información pública disponible
- Auditorías con autorización escrita
- Práctica en laboratorios dedicados

#### ❌ Actividades Prohibidas
- Escaneo no autorizado de sistemas ajenos
- Acceso a sistemas sin permiso
- Disruption de servicios
- Uso malicioso de información obtenida

#### 📋 Checklist de Autorización
- [ ] Autorización escrita del propietario
- [ ] Alcance claramente definido
- [ ] Horarios de trabajo establecidos
- [ ] Contactos de emergencia definidos
- [ ] Procedimientos de escalado establecidos

---

## 9. Ejercicios Prácticos

### 9.1 Ejercicio 1: Reconocimiento Básico

**Objetivo**: Realizar reconocimiento pasivo de un dominio.

**Pasos**:
1. Elegir un dominio público (ej: ejemplo.edu)
2. Realizar búsqueda WHOIS
3. Enumerar subdominios con al menos 2 herramientas
4. Buscar información en Shodan
5. Documentar hallazgos

**Deliverable**: Informe de 2 páginas con hallazgos.

### 9.2 Ejercicio 2: Escaneo con Nmap

**Objetivo**: Realizar escaneo completo de red de laboratorio.

**Entorno**: VirtualBox/VMware con máquinas vulnerables (Metasploitable, DVWA)

**Pasos**:
1. Descubrimiento de hosts
2. Escaneo de puertos TCP top 1000
3. Escaneo UDP en puertos comunes
4. Detección de servicios y versiones
5. Ejecución de scripts NSE relevantes

**Deliverable**: Reporte técnico con comandos utilizados y resultados.

### 9.3 Ejercicio 3: Comparación de Herramientas

**Objetivo**: Comparar eficiencia de diferentes scanners.

**Herramientas a comparar**:
- Nmap
- Masscan
- RustScan

**Métricas a evaluar**:
- Tiempo de ejecución
- Precisión de resultados
- Recursos utilizados
- Facilidad de uso

**Deliverable**: Tabla comparativa con análisis.

### 9.4 Ejercicio 4: OSINT Challenge

**Objetivo**: Extraer información de una organización ficticia.

**Tareas**:
1. Encontrar empleados usando LinkedIn
2. Generar lista de emails potenciales
3. Buscar documentos con metadatos
4. Crear organigrama parcial
5. Identificar tecnologías utilizadas

**Deliverable**: Dossier de inteligencia organizacional.

---

## 10. Recursos Adicionales

### 10.1 Herramientas Adicionales

#### Reconocimiento Web
- **Wappalyzer**: Identificación de tecnologías web
- **Builtwith**: Análisis de tecnologías de sitios web
- **Netcraft**: Información de hosting y tecnologías
- **SecurityHeaders**: Análisis de headers de seguridad

#### OSINT
- **Maltego**: Plataforma de análisis de enlaces
- **Spiderfoot**: Framework de automatización OSINT
- **Recon-ng**: Framework de reconocimiento modular
- **Photon**: Crawler para OSINT

#### DNS y Dominios
- **DNSRecon**: Enumeración de DNS avanzada
- **DNSenum**: Enumeración de información DNS
- **Fierce**: Escáner de dominios
- **DNSmap**: Scanner de subdominios

### 10.2 Wordlists Importantes

```bash
# SecLists (colección completa)
/usr/share/wordlists/SecLists/Discovery/DNS/
/usr/share/wordlists/SecLists/Discovery/Web-Content/
/usr/share/wordlists/SecLists/Usernames/

# Ubicaciones comunes en Kali Linux
/usr/share/wordlists/dirb/
/usr/share/wordlists/dirbuster/
/usr/share/wordlists/wfuzz/
```

### 10.3 Plataformas de Práctica

#### Gratuitas
- **TryHackMe**: Rooms de OSINT y reconocimiento
- **HackTheBox**: Máquinas para practicar reconocimiento
- **VulnHub**: Máquinas virtuales vulnerables
- **DVWA**: Aplicación web deliberadamente vulnerable

#### De Pago
- **Cybrary**: Cursos de ethical hacking
- **PentesterLab**: Laboratorios web específicos
- **eLearnSecurity**: Cursos avanzados de pentesting

### 10.4 Documentación y Referencias

#### Oficiales
- **Nmap Reference Guide**: https://nmap.org/book/
- **OWASP Testing Guide**: https://owasp.org/www-project-web-security-testing-guide/
- **NIST Cybersecurity Framework**: https://www.nist.gov/cybersecurity

#### Libros Recomendados
- "The Web Application Hacker's Handbook" - Stuttard & Pinto
- "Penetration Testing: A Hands-On Introduction" - Weidman
- "Open Source Intelligence Techniques" - Bazzell

#### Blogs y Recursos Online
- **Null-byte (WonderHowTo)**: Tutoriales de hacking ético
- **InfoSec Institute**: Artículos técnicos
- **SANS Reading Room**: Papers técnicos gratuitos

### 10.5 Comandos de Referencia Rápida

#### Nmap Quick Reference
```bash
# Escaneos básicos
nmap -sS -O -sV target          # Stealth + OS + Version detection
nmap -A target                  # Aggressive scan
nmap -sU --top-ports 100 target # UDP top ports
nmap --script vuln target       # Vulnerability scripts

# Timing y performance
nmap -T4 target                 # Fast timing
nmap --max-retries 1 target     # Reduce retries
nmap --host-timeout 5m target   # Timeout per host
```

#### Subdomain Enumeration
```bash
# Multiple tools pipeline
subfinder -d target.com | amass enum -passive -d target.com | sort -u > subs.txt
```

#### DNS Quick Checks
```bash
# Essential DNS records
dig target.com A MX NS TXT
```

---

## Conclusiones

La fase de reconocimiento es fundamental en cualquier auditoría de seguridad. Una recopilación exhaustiva de información puede marcar la diferencia entre un pentesting exitoso y uno superficial.

### Puntos Clave:
1. **La paciencia es crucial** - El reconocimiento no debe ser apresurado
2. **Combinar herramientas** - Ninguna herramienta es perfecta por sí sola
3. **Documentar todo** - La información recopilada es valiosa para fases posteriores
4. **Respetar límites legales** - Solo trabajar en entornos autorizados
5. **Mantenerse actualizado** - Las herramientas y técnicas evolucionan constantemente

### Próximos Pasos:
- Práctica regular con laboratorios
- Participación en CTFs
- Contribución a proyectos open source
- Obtención de certificaciones (CEH, OSCP, etc.)

---

**Nota**: Este material está diseñado con fines educativos para estudiantes de ASIR2. El uso de estas técnicas debe limitarse siempre a entornos autorizados y con propósitos legítimos de aprendizaje y auditoría de seguridad.

**Autor**: [Nombre del profesor/instructor]  
**Fecha**: Septiembre 2025

---

## 11. Laboratorios Prácticos Detallados

### 11.1 Laboratorio 1: Configuración del Entorno

#### Requisitos del Sistema
```bash
# Sistema operativo recomendado
- Kali Linux 2023.3 o superior
- Parrot Security OS
- Ubuntu/Debian con herramientas instaladas manualmente

# Recursos mínimos
- RAM: 4GB (recomendado 8GB)
- Almacenamiento: 50GB libre
- Conexión a Internet estable
```

#### Instalación de Herramientas Esenciales
```bash
# Actualizar sistema
sudo apt update && sudo apt upgrade -y

# Instalar herramientas básicas
sudo apt install -y nmap masscan rustscan gobuster subfinder amass \
theharvester shodan whatweb nikto dirb dirbuster wpscan \
sqlmap metasploit-framework exploitdb searchsploit

# Instalar herramientas adicionales
sudo apt install -y dnsrecon dnsenum fierce dnsmap recon-ng \
spiderfoot maltego photon osrframework holehe sherlock

# Herramientas de Python
pip3 install shodan censys requests beautifulsoup4 python-whois \
dnspython sublist3r builtwith-python

# Configuración de API keys (opcional)
mkdir ~/.config/
# Shodan API
echo "YOUR_SHODAN_API_KEY" > ~/.config/shodan_api_key
# Censys API
echo "YOUR_CENSYS_API_ID:YOUR_CENSYS_API_SECRET" > ~/.config/censys_api
```

#### Configuración de Laboratorio Virtual
```bash
# Descargar máquinas vulnerables para práctica
wget https://download.vulnhub.com/metasploitable/metasploitable-linux-2.0.0.zip
wget https://sourceforge.net/projects/dvwa/files/DVWA-1.10.zip

# Configurar red aislada en VirtualBox/VMware
# Red NAT para acceso a Internet
# Red interna para máquinas vulnerables
```

### 11.2 Laboratorio 2: Reconocimiento Pasivo Avanzado

#### Objetivo
Realizar reconocimiento completo de una organización sin interactuar directamente con sus sistemas.

#### Ejercicio Práctico: Análisis de "MegaCorp Inc."

**Paso 1: Búsqueda inicial con Google Dorking**
```bash
# Crear script para automatizar búsquedas
#!/bin/bash
# google_dorking.sh

TARGET="megacorp.com"
OUTPUT_DIR="recon_results"

mkdir -p $OUTPUT_DIR

echo "[+] Iniciando reconocimiento pasivo de $TARGET"

# Búsqueda de subdominios
echo "[*] Buscando subdominios..."
curl -s "https://www.google.com/search?q=site:$TARGET" | \
grep -oP "https?://[^/]*$TARGET" | sort -u > $OUTPUT_DIR/google_subdomains.txt

# Búsqueda de archivos específicos
echo "[*] Buscando archivos PDF..."
curl -s "https://www.google.com/search?q=site:$TARGET+filetype:pdf" | \
grep -oP "https?://[^\"]*\.pdf" > $OUTPUT_DIR/pdf_files.txt

echo "[*] Búsqueda completada. Revisar $OUTPUT_DIR/"
```

**Paso 2: Análisis con Shodan**
```python
#!/usr/bin/env python3
# shodan_recon.py

import shodan
import json
import sys

API_KEY = "YOUR_SHODAN_API_KEY"
api = shodan.Shodan(API_KEY)

def search_organization(org_name):
    try:
        # Búsqueda por organización
        results = api.search(f'org:"{org_name}"')
        
        print(f"[+] Encontrados {results['total']} resultados para {org_name}")
        
        for result in results['matches']:
            print(f"IP: {result['ip_str']}")
            print(f"Puerto: {result['port']}")
            print(f"Servicio: {result.get('product', 'Unknown')}")
            print(f"Versión: {result.get('version', 'Unknown')}")
            print(f"País: {result['location']['country_name']}")
            print("-" * 50)
            
    except shodan.APIError as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Uso: python3 shodan_recon.py 'Organization Name'")
        sys.exit(1)
    
    search_organization(sys.argv[1])
```

**Paso 3: Enumeración masiva de subdominios**
```bash
#!/bin/bash
# subdomain_enum.sh

TARGET=$1
OUTPUT_DIR="subdomains_$TARGET"

if [ -z "$TARGET" ]; then
    echo "Uso: $0 <domain>"
    exit 1
fi

mkdir -p $OUTPUT_DIR

echo "[+] Enumerando subdominios para $TARGET"

# Subfinder
echo "[*] Ejecutando Subfinder..."
subfinder -d $TARGET -silent > $OUTPUT_DIR/subfinder.txt

# Amass
echo "[*] Ejecutando Amass (pasivo)..."
amass enum -passive -d $TARGET > $OUTPUT_DIR/amass.txt

# Sublist3r
echo "[*] Ejecutando Sublist3r..."
python3 /opt/Sublist3r/sublist3r.py -d $TARGET -o $OUTPUT_DIR/sublist3r.txt

# Assetfinder
echo "[*] Ejecutando Assetfinder..."
assetfinder --subs-only $TARGET > $OUTPUT_DIR/assetfinder.txt

# Findomain
echo "[*] Ejecutando Findomain..."
findomain -t $TARGET -q > $OUTPUT_DIR/findomain.txt

# Combinar y limpiar resultados
echo "[*] Combinando resultados..."
cat $OUTPUT_DIR/*.txt | sort -u | grep -v "^\s*$" > $OUTPUT_DIR/all_subdomains.txt

# Verificar subdominios activos
echo "[*] Verificando subdominios activos..."
while read subdomain; do
    if dig +short $subdomain | grep -q .; then
        echo $subdomain >> $OUTPUT_DIR/active_subdomains.txt
    fi
done < $OUTPUT_DIR/all_subdomains.txt

echo "[+] Enumeración completada:"
echo "    Total encontrados: $(cat $OUTPUT_DIR/all_subdomains.txt | wc -l)"
echo "    Activos: $(cat $OUTPUT_DIR/active_subdomains.txt | wc -l)"
```

### 11.3 Laboratorio 3: Escaneo Avanzado con Nmap

#### Scripts Personalizados NSE

**Script personalizado para detección web**
```lua
-- http-custom-enum.nse
description = [[
Enumeración personalizada de servicios HTTP
Detecta tecnologías, frameworks y posibles vulnerabilidades
]]

author = "Estudiante ASIR2"
license = "GPL v2"
categories = {"discovery", "safe"}

local http = require "http"
local shortport = require "shortport"
local stdnse = require "stdnse"

portrule = shortport.http

action = function(host, port)
    local result = {}
    
    -- Obtener headers
    local response = http.get(host, port, "/")
    if not response or not response.header then
        return nil
    end
    
    -- Analizar Server header
    if response.header.server then
        table.insert(result, "Server: " .. response.header.server)
    end
    
    -- Analizar X-Powered-By
    if response.header["x-powered-by"] then
        table.insert(result, "X-Powered-By: " .. response.header["x-powered-by"])
    end
    
    -- Buscar frameworks en HTML
    if response.body then
        if string.find(response.body:lower(), "wordpress") then
            table.insert(result, "Framework: WordPress detectado")
        elseif string.find(response.body:lower(), "drupal") then
            table.insert(result, "Framework: Drupal detectado")
        elseif string.find(response.body:lower(), "joomla") then
            table.insert(result, "Framework: Joomla detectado")
        end
    end
    
    return stdnse.format_output(true, result)
end
```

**Uso del script personalizado**
```bash
# Copiar script a directorio NSE
sudo cp http-custom-enum.nse /usr/share/nmap/scripts/

# Actualizar base de datos
sudo nmap --script-updatedb

# Usar script personalizado
nmap --script http-custom-enum ejemplo.com
```

#### Plantillas de Escaneo Automatizado

```bash
#!/bin/bash
# nmap_comprehensive.sh

TARGET=$1
OUTPUT_DIR="nmap_scan_$(date +%Y%m%d_%H%M%S)"

if [ -z "$TARGET" ]; then
    echo "Uso: $0 <target>"
    exit 1
fi

mkdir -p $OUTPUT_DIR

echo "[+] Iniciando escaneo comprehensivo de $TARGET"
echo "[*] Resultados en: $OUTPUT_DIR"

# Paso 1: Descubrimiento de hosts
echo "[*] Paso 1: Descubrimiento de hosts..."
nmap -sn $TARGET -oA $OUTPUT_DIR/01_host_discovery

# Paso 2: Escaneo rápido de puertos comunes
echo "[*] Paso 2: Escaneo rápido de puertos..."
nmap -sS -T4 -F $TARGET -oA $OUTPUT_DIR/02_fast_scan

# Paso 3: Escaneo completo de puertos TCP
echo "[*] Paso 3: Escaneo completo TCP..."
nmap -sS -p- -T4 $TARGET -oA $OUTPUT_DIR/03_full_tcp

# Paso 4: Escaneo UDP en puertos comunes
echo "[*] Paso 4: Escaneo UDP..."
nmap -sU --top-ports 100 $TARGET -oA $OUTPUT_DIR/04_udp_scan

# Paso 5: Detección de servicios y versiones
echo "[*] Paso 5: Detección de servicios..."
nmap -sS -sV -A -T4 $TARGET -oA $OUTPUT_DIR/05_service_detection

# Paso 6: Scripts de vulnerabilidades
echo "[*] Paso 6: Búsqueda de vulnerabilidades..."
nmap --script vuln $TARGET -oA $OUTPUT_DIR/06_vulnerability_scan

# Paso 7: Scripts específicos por servicio
echo "[*] Paso 7: Scripts específicos..."

# HTTP/HTTPS
nmap --script "http-*" -p 80,443,8080,8443 $TARGET -oA $OUTPUT_DIR/07_http_scripts

# SSH
nmap --script "ssh-*" -p 22 $TARGET -oA $OUTPUT_DIR/07_ssh_scripts

# SMB
nmap --script "smb-*" -p 139,445 $TARGET -oA $OUTPUT_DIR/07_smb_scripts

# DNS
nmap --script "dns-*" -p 53 $TARGET -oA $OUTPUT_DIR/07_dns_scripts

echo "[+] Escaneo completado. Generando reporte..."

# Generar reporte HTML
./generate_report.py $OUTPUT_DIR > $OUTPUT_DIR/report.html

echo "[+] Reporte disponible en: $OUTPUT_DIR/report.html"
```

### 11.4 Laboratorio 4: Automatización con Python

#### Framework de Reconocimiento Personalizado

```python
#!/usr/bin/env python3
# recon_framework.py

import subprocess
import requests
import json
import dns.resolver
import whois
import socket
from concurrent.futures import ThreadPoolExecutor
import argparse
import os
from datetime import datetime

class ReconFramework:
    def __init__(self, target, output_dir=None):
        self.target = target
        self.output_dir = output_dir or f"recon_{target}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        os.makedirs(self.output_dir, exist_ok=True)
        
    def log(self, message, level="INFO"):
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"[{timestamp}] [{level}] {message}")
        
    def save_results(self, filename, data):
        filepath = os.path.join(self.output_dir, filename)
        with open(filepath, 'w') as f:
            if isinstance(data, (dict, list)):
                json.dump(data, f, indent=2)
            else:
                f.write(str(data))
        self.log(f"Resultados guardados en {filepath}")
    
    def whois_lookup(self):
        """Información WHOIS del dominio"""
        self.log("Realizando consulta WHOIS...")
        try:
            w = whois.whois(self.target)
            whois_data = {
                'domain': w.domain,
                'registrar': w.registrar,
                'creation_date': str(w.creation_date),
                'expiration_date': str(w.expiration_date),
                'name_servers': w.name_servers
            }
            self.save_results('whois.json', whois_data)
            return whois_data
        except Exception as e:
            self.log(f"Error en WHOIS: {e}", "ERROR")
            return None
    
    def dns_enumeration(self):
        """Enumeración de registros DNS"""
        self.log("Enumerando registros DNS...")
        dns_records = {}
        
        record_types = ['A', 'AAAA', 'CNAME', 'MX', 'NS', 'TXT', 'SOA']
        
        for record_type in record_types:
            try:
                answers = dns.resolver.resolve(self.target, record_type)
                dns_records[record_type] = [str(rdata) for rdata in answers]
            except:
                dns_records[record_type] = []
        
        self.save_results('dns_records.json', dns_records)
        return dns_records
    
    def subdomain_enumeration(self):
        """Enumeración de subdominios usando múltiples herramientas"""
        self.log("Enumerando subdominios...")
        subdomains = set()
        
        # Subfinder
        try:
            result = subprocess.run(['subfinder', '-d', self.target, '-silent'], 
                                  capture_output=True, text=True, timeout=300)
            subdomains.update(result.stdout.strip().split('\n'))
        except:
            pass
        
        # Amass pasivo
        try:
            result = subprocess.run(['amass', 'enum', '-passive', '-d', self.target], 
                                  capture_output=True, text=True, timeout=300)
            subdomains.update(result.stdout.strip().split('\n'))
        except:
            pass
        
        # Limpiar resultados
        subdomains = [sub for sub in subdomains if sub and self.target in sub]
        
        self.save_results('subdomains.txt', '\n'.join(sorted(subdomains)))
        return list(subdomains)
    
    def port_scan(self, hosts=None):
        """Escaneo de puertos con Nmap"""
        self.log("Iniciando escaneo de puertos...")
        targets = hosts or [self.target]
        
        for host in targets:
            self.log(f"Escaneando {host}...")
            
            # Escaneo rápido
            cmd = ['nmap', '-sS', '-T4', '--top-ports', '1000', 
                   '-oA', f"{self.output_dir}/nmap_{host.replace('.', '_')}", host]
            
            try:
                subprocess.run(cmd, timeout=600)
            except subprocess.TimeoutExpired:
                self.log(f"Timeout en escaneo de {host}", "WARNING")
    
    def web_enumeration(self, urls):
        """Enumeración web básica"""
        self.log("Enumerando servicios web...")
        web_info = {}
        
        for url in urls:
            try:
                response = requests.get(f"http://{url}", timeout=10)
                web_info[url] = {
                    'status_code': response.status_code,
                    'headers': dict(response.headers),
                    'title': self.extract_title(response.text)
                }
            except:
                web_info[url] = {'error': 'No accesible'}
        
        self.save_results('web_info.json', web_info)
        return web_info
    
    def extract_title(self, html):
        """Extraer título de página HTML"""
        import re
        match = re.search(r'<title>(.*?)</title>', html, re.IGNORECASE)
        return match.group(1) if match else "Sin título"
    
    def run_full_recon(self):
        """Ejecutar reconocimiento completo"""
        self.log(f"Iniciando reconocimiento completo de {self.target}")
        
        # WHOIS
        whois_data = self.whois_lookup()
        
        # DNS
        dns_data = self.dns_enumeration()
        
        # Subdominios
        subdomains = self.subdomain_enumeration()
        
        # Escaneo de puertos
        all_hosts = [self.target] + subdomains[:10]  # Limitar a 10 subdominios
        self.port_scan(all_hosts)
        
        # Web enumeration
        web_hosts = [host for host in all_hosts if self.is_web_service(host)]
        if web_hosts:
            self.web_enumeration(web_hosts)
        
        self.generate_summary()
        self.log(f"Reconocimiento completado. Resultados en: {self.output_dir}")
    
    def is_web_service(self, host):
        """Verificar si el host tiene servicio web"""
        for port in [80, 443, 8080, 8443]:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(3)
                result = sock.connect_ex((host, port))
                sock.close()
                if result == 0:
                    return True
            except:
                pass
        return False
    
    def generate_summary(self):
        """Generar resumen de resultados"""
        summary = f"""
# Resumen de Reconocimiento - {self.target}
## Fecha: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

## Archivos generados:
"""
        for file in os.listdir(self.output_dir):
            summary += f"- {file}\n"
        
        self.save_results('summary.md', summary)

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Framework de Reconocimiento')
    parser.add_argument('target', help='Dominio objetivo')
    parser.add_argument('-o', '--output', help='Directorio de salida')
    
    args = parser.parse_args()
    
    recon = ReconFramework(args.target, args.output)
    recon.run_full_recon()
```

### 11.5 Laboratorio 5: Análisis de Resultados

#### Herramienta de Análisis de Vulnerabilidades

```python
#!/usr/bin/env python3
# vuln_analyzer.py

import xml.etree.ElementTree as ET
import json
import csv
import argparse
from collections import defaultdict

class VulnAnalyzer:
    def __init__(self):
        self.vulnerabilities = []
        self.services = []
        self.hosts = []
    
    def parse_nmap_xml(self, xml_file):
        """Parsear archivo XML de Nmap"""
        tree = ET.parse(xml_file)
        root = tree.getroot()
        
        for host in root.findall('host'):
            host_info = {
                'ip': host.find('address').get('addr'),
                'ports': [],
                'os': None
            }
            
            # Información del OS
            os_elem = host.find('.//os/osmatch')
            if os_elem is not None:
                host_info['os'] = os_elem.get('name')
            
            # Puertos y servicios
            ports_elem = host.find('ports')
            if ports_elem is not None:
                for port in ports_elem.findall('port'):
                    port_info = {
                        'number': port.get('portid'),
                        'protocol': port.get('protocol'),
                        'state': port.find('state').get('state'),
                        'service': None,
                        'version': None
                    }
                    
                    service_elem = port.find('service')
                    if service_elem is not None:
                        port_info['service'] = service_elem.get('name')
                        port_info['version'] = service_elem.get('version')
                    
                    host_info['ports'].append(port_info)
            
            self.hosts.append(host_info)
    
    def identify_vulnerabilities(self):
        """Identificar posibles vulnerabilidades basadas en versiones"""
        vuln_db = {
            'apache': {
                '2.2.8': ['CVE-2009-3555', 'CVE-2010-0408'],
                '2.4.7': ['CVE-2014-0098', 'CVE-2014-0226']
            },
            'openssh': {
                '5.3': ['CVE-2010-4478'],
                '6.6': ['CVE-2016-0777', 'CVE-2016-0778']
            },
            'mysql': {
                '5.0': ['CVE-2012-2122'],
                '5.5.7': ['CVE-2012-0572']
            }
        }
        
        for host in self.hosts:
            for port in host['ports']:
                service = port.get('service', '').lower()
                version = port.get('version', '')
                
                if service in vuln_db:
                    for vuln_version, cves in vuln_db[service].items():
                        if vuln_version in version:
                            for cve in cves:
                                self.vulnerabilities.append({
                                    'host': host['ip'],
                                    'port': port['number'],
                                    'service': service,
                                    'version': version,
                                    'cve': cve,
                                    'severity': self.get_severity(cve)
                                })
    
    def get_severity(self, cve):
        """Obtener severidad de CVE (simplificado)"""
        # En implementación real, consultaría base de datos CVSS
        critical_cves = ['CVE-2014-0160', 'CVE-2017-0144']  # Ejemplos
        if cve in critical_cves:
            return 'Critical'
        return 'Medium'  # Por defecto
    
    def generate_report(self, output_format='json'):
        """Generar reporte de vulnerabilidades"""
        if output_format == 'json':
            return json.dumps({
                'hosts': self.hosts,
                'vulnerabilities': self.vulnerabilities,
                'summary': self.get_summary()
            }, indent=2)
        
        elif output_format == 'csv':
            output = []
            for vuln in self.vulnerabilities:
                output.append([
                    vuln['host'], vuln['port'], vuln['service'],
                    vuln['version'], vuln['cve'], vuln['severity']
                ])
            return output
    
    def get_summary(self):
        """Generar resumen de hallazgos"""
        severity_count = defaultdict(int)
        service_count = defaultdict(int)
        
        for vuln in self.vulnerabilities:
            severity_count[vuln['severity']] += 1
            service_count[vuln['service']] += 1
        
        return {
            'total_hosts': len(self.hosts),
            'total_vulnerabilities': len(self.vulnerabilities),
            'by_severity': dict(severity_count),
            'by_service': dict(service_count)
        }

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Analizador de Vulnerabilidades')
    parser.add_argument('xml_file', help='Archivo XML de Nmap')
    parser.add_argument('-f', '--format', choices=['json', 'csv'], 
                       default='json', help='Formato de salida')
    
    args = parser.parse_args()
    
    analyzer = VulnAnalyzer()
    analyzer.parse_nmap_xml(args.xml_file)
    analyzer.identify_vulnerabilities()
    
    report = analyzer.generate_report(args.format)
    
    if args.format == 'json':
        print(report)
    else:  # CSV
        writer = csv.writer(sys.stdout)
        writer.writerow(['Host', 'Port', 'Service', 'Version', 'CVE', 'Severity'])
        writer.writerows(report)
```

---

## 12. Casos de Estudio Reales

### 12.1 Caso de Estudio 1: Auditoría de Red Corporativa

#### Escenario
Una empresa mediana (500 empleados) solicita auditoría de su perímetro de red. Tienen presencia web, correo corporativo y acceso VPN.

#### Metodología Aplicada

**Fase 1: Reconocimiento Pasivo (2 días)**
```bash
# Recopilación inicial
Company: "TechCorp Solutions"
Domain: techcorp-solutions.com
IP Range: 203.0.113.0/24 (ejemplo)

# Información WHOIS
Registrar: GoDaddy
Created: 2015-03-15
Expires: 2025-03-15
Name Servers: ns1.techcorp-solutions.com, ns2.techcorp-solutions.com

# Subdominios identificados (25 encontrados)
- www.techcorp-solutions.com
- mail.techcorp-solutions.com
- vpn.techcorp-solutions.com
- ftp.techcorp-solutions.com
- dev.techcorp-solutions.com
- staging.techcorp-solutions.com
```

**Fase 2: Reconocimiento Activo (3 días)**
```bash
# Escaneo de red
nmap -sS -O -sV -p- 203.0.113.0/24

# Resultados principales:
203.0.113.10 - Web Server (Apache 2.4.41, PHP 7.4)
203.0.113.20 - Mail Server (Postfix, Dovecot)
203.0.113.30 - VPN Gateway (OpenVPN)
203.0.113.40 - FTP Server (vsftpd 3.0.2)
203.0.113.50 - Development Server (Nginx, Node.js)
```

#### Hallazgos Críticos
1. **Servidor FTP con credenciales por defecto**
2. **Servidor de desarrollo accesible desde Internet**
3. **Versiones desactualizadas de Apache y PHP**
4. **Certificados SSL próximos a expirar**

#### Recomendaciones
- Cambiar credenciales por defecto
- Mover servidor de desarrollo a red interna
- Actualizar software desactualizado
- Renovar certificados SSL

### 12.2 Caso de Estudio 2: E-commerce con Vulnerabilidades

#### Escenario
Tienda online que reporta actividad sospechosa. Se requiere evaluación de seguridad urgente.

#### Descubrimientos durante Reconocimiento
```bash
# Tecnologías identificadas
- WordPress 5.2.4 (vulnerable)
- WooCommerce 3.8.1
- MySQL 5.7
- PHP 7.2

# Plugins vulnerables detectados
- Revolution Slider 5.4.8 (CVE-2020-11292)
- Contact Form 7 (versión desactualizada)

# Información sensible expuesta
- /wp-config.php.bak (archivo de backup)
- /debug.log (logs con información sensible)
- Directorio /uploads sin protección
```

#### Vector de Ataque Identificado
1. Exploit en Revolution Slider → Shell upload
2. Escalación mediante MySQL UDF
3. Acceso a base de datos de clientes

### 12.3 Caso de Estudio 3: Infraestructura Cloud

#### Escenario
Startup que migró a AWS presenta configuraciones inseguras.

#### Hallazgos en Reconocimiento
```bash
# Buckets S3 públicos
aws s3 ls --no-sign-request s3://company-backups
aws s3 ls --no-sign-request s3://company-logs-2023

# Instancias EC2 expuestas
Instance i-0123456789abcdef0:
- Security Group: default (0.0.0.0/0:22)
- AMI: Ubuntu 18.04 (desactualizada)
- No MFA en usuarios IAM

# Bases de datos RDS
- Puerto 3306 abierto a 0.0.0.0/0
- Backups sin cifrar
- Credenciales en variables de entorno
```

---

## 13. Herramientas Emergentes y Tendencias

### 13.1 Herramientas de IA para Reconocimiento

#### GPT-powered OSINT
```python
# osint_gpt.py - Ejemplo conceptual
import openai

class OSINTAssistant:
    def __init__(self, api_key):
        self.client = openai.OpenAI(api_key=api_key)
    
    def analyze_company(self, company_name):
        prompt = f"""
        Actúa como un experto en OSINT. Para la empresa "{company_name}":
        1. Sugiere fuentes de información pública
        2. Identifica posibles subdominios
        3. Lista tecnologías probables
        4. Recomienda estrategias de reconocimiento
        
        Responde solo con información de fuentes públicas.
        """
        
        response = self.client.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}]
        )
        
        return response.choices[0].message.content
```

### 13.2 Automatización con APIs Modernas

#### Integration Framework
```python
# modern_recon.py
import asyncio
import aiohttp
from dataclasses import dataclass
from typing import List, Dict, Optional
import json

@dataclass
class ReconResult:
    source: str
    data: Dict
    timestamp: str

class ModernReconFramework:
    def __init__(self):
        self.results = []
        self.session = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def shodan_search(self, api_key: str, query: str):
        """Búsqueda asíncrona en Shodan"""
        url = f"https://api.shodan.io/shodan/host/search?key={api_key}&q={query}"
        async with self.session.get(url) as response:
            if response.status == 200:
                data = await response.json()
                return ReconResult("shodan", data, "2024")
    
    async def censys_search(self, api_id: str, api_secret: str, query: str):
        """Búsqueda asíncrona en Censys"""
        url = "https://search.censys.io/api/v2/hosts/search"
        auth = aiohttp.BasicAuth(api_id, api_secret)
        payload = {"q": query, "per_page": 100}
        
        async with self.session.get(url, auth=auth, params=payload) as response:
            if response.status == 200:
                data = await response.json()
                return ReconResult("censys", data, "2024")
    
    async def run_parallel_recon(self, target: str, configs: Dict):
        """Ejecutar reconocimiento paralelo"""
        tasks = []
        
        if "shodan" in configs:
            tasks.append(self.shodan_search(
                configs["shodan"]["api_key"], 
                f"hostname:{target}"
            ))
        
        if "censys" in configs:
            tasks.append(self.censys_search(
                configs["censys"]["api_id"],
                configs["censys"]["api_secret"],
                f"services.http.response.html_title: {target}"
            ))
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        self.results.extend([r for r in results if isinstance(r, ReconResult)])
        
        return self.results

# Uso del framework
async def main():
    configs = {
        "shodan": {"api_key": "YOUR_API_KEY"},
        "censys": {"api_id": "YOUR_ID", "api_secret": "YOUR_SECRET"}
    }
    
    async with ModernReconFramework() as recon:
        results = await recon.run_parallel_recon("example.com", configs)
        
        for result in results:
            print(f"Source: {result.source}")
            print(f"Data: {json.dumps(result.data, indent=2)[:200]}...")
            print("-" * 50)

# asyncio.run(main())
```

### 13.3 Técnicas Avanzadas de Evasión

#### Distributed Scanning
```bash
#!/bin/bash
# distributed_scan.sh

TARGET=$1
PROXY_LIST="proxies.txt"
OUTPUT_DIR="distributed_scan"

mkdir -p $OUTPUT_DIR

# Dividir rangos entre múltiples proxies
split_and_scan() {
    local proxy=$1
    local port_range=$2
    local target=$3
    
    # Configurar proxy para Nmap (requiere proxychains)
    echo "socks5 $proxy" > /tmp/proxychains_$.conf
    
    # Escaneo a través del proxy
    proxychains4 -f /tmp/proxychains_$.conf \
        nmap -sS -T2 -p $port_range $target \
        -oA $OUTPUT_DIR/scan_${proxy//./_}_$port_range
    
    rm /tmp/proxychains_$.conf
}

# Leer lista de proxies y distribuir trabajo
proxy_count=$(wc -l < $PROXY_LIST)
ports_per_proxy=$((65535 / proxy_count))

counter=1
while read proxy; do
    start_port=$((($counter - 1) * $ports_per_proxy + 1))
    end_port=$(($counter * $ports_per_proxy))
    
    if [ $counter -eq $proxy_count ]; then
        end_port=65535
    fi
    
    echo "[+] Escaneando puertos $start_port-$end_port via $proxy"
    split_and_scan $proxy $start_port-$end_port $TARGET &
    
    counter=$((counter + 1))
done < $PROXY_LIST

wait
echo "[+] Escaneo distribuido completado"
```

#### DNS over HTTPS (DoH) para Evasión
```python
#!/usr/bin/env python3
# doh_enum.py

import requests
import base64
import json
from concurrent.futures import ThreadPoolExecutor

class DoHResolver:
    def __init__(self):
        self.providers = [
            "https://cloudflare-dns.com/dns-query",
            "https://dns.google/dns-query",
            "https://dns.quad9.net/dns-query"
        ]
    
    def dns_query(self, domain, record_type="A", provider=None):
        """Realizar consulta DNS sobre HTTPS"""
        if not provider:
            provider = self.providers[0]
        
        headers = {
            "Accept": "application/dns-json",
            "User-Agent": "DoH-Client/1.0"
        }
        
        params = {
            "name": domain,
            "type": record_type
        }
        
        try:
            response = requests.get(provider, headers=headers, params=params)
            if response.status_code == 200:
                return response.json()
        except:
            return None
    
    def enumerate_subdomains_doh(self, domain, wordlist):
        """Enumerar subdominios usando DoH"""
        found_subdomains = []
        
        def check_subdomain(subdomain):
            full_domain = f"{subdomain}.{domain}"
            result = self.dns_query(full_domain)
            
            if result and result.get("Answer"):
                return full_domain
            return None
        
        # Usar ThreadPoolExecutor para paralelización
        with ThreadPoolExecutor(max_workers=20) as executor:
            results = list(executor.map(check_subdomain, wordlist))
        
        return [r for r in results if r]

# Ejemplo de uso
if __name__ == "__main__":
    resolver = DoHResolver()
    
    # Wordlist básica
    wordlist = ["www", "mail", "ftp", "admin", "test", "dev", "api"]
    
    subdomains = resolver.enumerate_subdomains_doh("example.com", wordlist)
    
    for subdomain in subdomains:
        print(f"[+] Found: {subdomain}")
```

---

## 14. Integración con Frameworks de Seguridad

### 14.1 Integración con Metasploit

#### Importar Resultados de Nmap
```bash
# En consola de Metasploit
msfconsole

# Crear workspace
workspace -a recon_project

# Importar escaneo de Nmap
db_import /path/to/nmap_scan.xml

# Ver hosts importados
hosts

# Ver servicios
services

# Buscar exploits para servicios encontrados
search type:exploit platform:linux apache

# Usar auxiliary modules para más reconocimiento
use auxiliary/scanner/http/http_version
set RHOSTS 192.168.1.100
run
```

#### Script de Automatización
```ruby
# auto_recon.rc - Script de Metasploit
# Uso: msfconsole -r auto_recon.rc

workspace -a auto_recon
setg RHOSTS 192.168.1.0/24

# HTTP enumeration
use auxiliary/scanner/http/http_version
run

use auxiliary/scanner/http/dir_scanner
set DICTIONARY /usr/share/metasploit-framework/data/wordlists/directory.txt
run

# SSH enumeration
use auxiliary/scanner/ssh/ssh_version
run

# SMB enumeration
use auxiliary/scanner/smb/smb_version
run

use auxiliary/scanner/smb/smb_enumshares
run

# Generate report
hosts -o /tmp/hosts.txt
services -o /tmp/services.txt
```

### 14.2 Integración con OpenVAS/GVM

#### Automatización de Escaneos
```python
#!/usr/bin/env python3
# openvas_integration.py

from gvm.connections import UnixSocketConnection
from gvm.protocols.gmp import Gmp
from gvm.transforms import EtreeTransform
import time

class OpenVASManager:
    def __init__(self, socket_path="/var/run/gvmd.sock"):
        self.socket_path = socket_path
        self.gmp = None
    
    def connect(self, username, password):
        """Conectar a OpenVAS"""
        connection = UnixSocketConnection(path=self.socket_path)
        transform = EtreeTransform()
        
        self.gmp = Gmp(connection=connection, transform=transform)
        self.gmp.authenticate(username, password)
    
    def create_target(self, name, hosts):
        """Crear objetivo de escaneo"""
        response = self.gmp.create_target(
            name=name,
            hosts=[hosts]
        )
        return response.get('id')
    
    def create_and_start_scan(self, target_name, hosts, scan_config="Full and fast"):
        """Crear y iniciar escaneo"""
        # Crear objetivo
        target_id = self.create_target(target_name, hosts)
        
        # Obtener configuración de escaneo
        configs = self.gmp.get_scan_configs()
        config_id = None
        
        for config in configs.xpath('config'):
            if scan_config in config.find('name').text:
                config_id = config.get('id')
                break
        
        if not config_id:
            raise ValueError(f"Configuración '{scan_config}' no encontrada")
        
        # Crear tarea
        task_response = self.gmp.create_task(
            name=f"Scan_{target_name}",
            config_id=config_id,
            target_id=target_id
        )
        
        task_id = task_response.get('id')
        
        # Iniciar escaneo
        self.gmp.start_task(task_id)
        
        return task_id
    
    def wait_for_scan_completion(self, task_id):
        """Esperar a que termine el escaneo"""
        while True:
            task = self.gmp.get_task(task_id)
            status = task.find('status').text
            
            print(f"Estado del escaneo: {status}")
            
            if status == "Done":
                break
            elif status in ["Stopped", "Interrupted"]:
                raise Exception(f"Escaneo terminó con estado: {status}")
            
            time.sleep(30)
    
    def get_scan_results(self, task_id, format="XML"):
        """Obtener resultados del escaneo"""
        # Obtener ID del reporte
        reports = self.gmp.get_reports(task_id=task_id)
        report_id = reports.xpath('report/@id')[0]
        
        # Descargar reporte
        response = self.gmp.get_report(
            report_id=report_id,
            report_format_id="a994b278-1f62-11e1-96ac-406186ea4fc5"  # XML format
        )
        
        return response

# Ejemplo de uso
if __name__ == "__main__":
    scanner = OpenVASManager()
    scanner.connect("admin", "password")
    
    # Crear y iniciar escaneo
    task_id = scanner.create_and_start_scan("Test Target", "192.168.1.100")
    
    # Esperar resultados
    scanner.wait_for_scan_completion(task_id)
    
    # Obtener resultados
    results = scanner.get_scan_results(task_id)
    
    # Guardar resultados
    with open("openvas_results.xml", "w") as f:
        f.write(results)
```

### 14.3 SIEM Integration

#### Script para Splunk
```python
#!/usr/bin/env python3
# splunk_logger.py

import requests
import json
import time
from datetime import datetime

class SplunkLogger:
    def __init__(self, splunk_host, hec_token, index="security"):
        self.splunk_host = splunk_host
        self.hec_token = hec_token
        self.index = index
        self.hec_url = f"https://{splunk_host}:8088/services/collector/event"
    
    def log_recon_event(self, event_type, source_ip, target, details):
        """Registrar evento de reconocimiento en Splunk"""
        event = {
            "time": int(time.time()),
            "host": source_ip,
            "source": "recon_framework",
            "sourcetype": "recon:event",
            "index": self.index,
            "event": {
                "event_type": event_type,
                "source_ip": source_ip,
                "target": target,
                "details": details,
                "timestamp": datetime.now().isoformat()
            }
        }
        
        headers = {
            "Authorization": f"Splunk {self.hec_token}",
            "Content-Type": "application/json"
        }
        
        try:
            response = requests.post(
                self.hec_url,
                data=json.dumps(event),
                headers=headers,
                verify=False
            )
            
            if response.status_code == 200:
                print(f"[+] Evento enviado a Splunk: {event_type}")
            else:
                print(f"[-] Error enviando evento: {response.status_code}")
        
        except Exception as e:
            print(f"[-] Error: {e}")

# Ejemplo de uso integrado con reconocimiento
def recon_with_logging():
    logger = SplunkLogger("splunk.empresa.com", "YOUR-HEC-TOKEN")
    
    # Simular eventos de reconocimiento
    targets = ["example.com", "test.example.com", "mail.example.com"]
    
    for target in targets:
        # Log inicio de escaneo
        logger.log_recon_event(
            "port_scan_start",
            "10.0.0.50",  # IP del scanner
            target,
            {"scan_type": "tcp", "ports": "1-1000"}
        )
        
        # Simular resultados
        open_ports = [22, 80, 443]
        for port in open_ports:
            logger.log_recon_event(
                "open_port_found",
                "10.0.0.50",
                target,
                {"port": port, "protocol": "tcp", "state": "open"}
            )
        
        # Log fin de escaneo
        logger.log_recon_event(
            "port_scan_complete",
            "10.0.0.50",
            target,
            {"total_ports_scanned": 1000, "open_ports": len(open_ports)}
        )

if __name__ == "__main__":
    recon_with_logging()
```

---

## 15. Laboratorio Final: Proyecto Integrador

### 15.1 Especificaciones del Proyecto

#### Objetivo
Desarrollar una herramienta completa de reconocimiento que integre múltiples fuentes de información y genere reportes profesionales.

#### Requisitos Funcionales
1. **Reconocimiento pasivo automatizado**
2. **Escaneo activo con múltiples herramientas**
3. **Análisis de vulnerabilidades**
4. **Generación de reportes HTML/PDF**
5. **Integración con APIs de threat intelligence**
6. **Logging y auditabilidad**

#### Arquitectura del Sistema
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Web Interface │    │  Core Engine    │    │   Data Storage  │
│   (Flask/Django)│◄──►│   (Python)      │◄──►│   (SQLite/JSON) │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                              │
                    ┌─────────┼─────────┐
                    │         │         │
            ┌───────▼───┐ ┌───▼────┐ ┌──▼─────┐
            │ Passive   │ │ Active │ │ Report │
            │ Recon     │ │ Recon  │ │ Engine │
            └───────────┘ └────────┘ └────────┘
```

### 15.2 Implementación del Core Engine

```python
#!/usr/bin/env python3
# recon_platform.py

import asyncio
import sqlite3
import json
import logging
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional
import uuid

class ReconPlatform:
    def __init__(self, db_path="recon.db"):
        self.db_path = db_path
        self.logger = self.setup_logging()
        self.init_database()
    
    def setup_logging(self):
        """Configurar logging"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('recon.log'),
                logging.StreamHandler()
            ]
        )
        return logging.getLogger('ReconPlatform')
    
    def init_database(self):
        """Inicializar base de datos"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Tabla de proyectos
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS projects (
                id TEXT PRIMARY KEY,
                name TEXT NOT NULL,
                target TEXT NOT NULL,
                created_at TIMESTAMP,
                status TEXT DEFAULT 'active'
            )
        ''')
        
        # Tabla de resultados
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS results (
                id TEXT PRIMARY KEY,
                project_id TEXT,
                module TEXT NOT NULL,
                result_type TEXT NOT NULL,
                data JSON,
                created_at TIMESTAMP,
                FOREIGN KEY (project_id) REFERENCES projects (id)
            )
        ''')
        
        conn.commit()
        conn.close()
    
    def create_project(self, name: str, target: str) -> str:
        """Crear nuevo proyecto"""
        project_id = str(uuid.uuid4())
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO projects (id, name, target, created_at)
            VALUES (?, ?, ?, ?)
        ''', (project_id, name, target, datetime.now()))
        
        conn.commit()
        conn.close()
        
        self.logger.info(f"Proyecto creado: {name} ({project_id})")
        return project_id
    
    def save_result(self, project_id: str, module: str, result_type: str, data: Dict):
        """Guardar resultado en base de datos"""
        result_id = str(uuid.uuid4())
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute('''
            INSERT INTO results (id, project_id, module, result_type, data, created_at)
            VALUES (?, ?, ?, ?, ?, ?)
        ''', (result_id, project_id, module, result_type, json.dumps(data), datetime.now()))
        
        conn.commit()
        conn.close()
    
    async def run_reconnaissance(self, project_id: str, target: str, modules: List[str]):
        """Ejecutar reconocimiento completo"""
        self.logger.info(f"Iniciando reconocimiento de {target}")
        
        # Módulos disponibles
        available_modules = {
            'whois': self.whois_module,
            'dns': self.dns_module,
            'subdomain': self.subdomain_module,
            'portscan': self.portscan_module,
            'web': self.web_module
        }
        
        # Ejecutar módulos seleccionados
        for module_name in modules:
            if module_name in available_modules:
                self.logger.info(f"Ejecutando módulo: {module_name}")
                try:
                    result = await available_modules[module_name](target)
                    self.save_result(project_id, module_name, 'scan_result', result)
                except Exception as e:
                    self.logger.error(f"Error en módulo {module_name}: {e}")
    
    async def whois_module(self, target: str) -> Dict:
        """Módulo de información WHOIS"""
        # Implementación simplificada
        return {
            'domain': target,
            'registrar': 'Example Registrar',
            'created': '2020-01-01',
            'expires': '2025-01-01'
        }
    
    async def dns_module(self, target: str) -> Dict:
        """Módulo de enumeración DNS"""
        # Implementación simplificada
        return {
            'a_records': ['203.0.113.1'],
            'mx_records': ['mail.example.com'],
            'ns_records': ['ns1.example.com', 'ns2.example.com']
        }
    
    async def subdomain_module(self, target: str) -> Dict:
        """Módulo de enumeración de subdominios"""
        # Implementación usando herramientas reales
        import subprocess
        
        try:
            # Usar subfinder
            result = subprocess.run(
                ['subfinder', '-d', target, '-silent'],
                capture_output=True, text=True, timeout=300
            )
            
            subdomains = [sub.strip() for sub in result.stdout.split('\n') if sub.strip()]
            
            return {
                'subdomains': subdomains,
                'count': len(subdomains),
                'tool': 'subfinder'
            }
        except Exception as e:
            self.logger.error(f"Error en enumeración de subdominios: {e}")
            return {'error': str(e)}
    
    async def portscan_module(self, target: str) -> Dict:
        """Módulo de escaneo de puertos"""
        import subprocess
        
        try:
            # Usar nmap
            result = subprocess.run([
                'nmap', '-sS', '-T4', '--top-ports', '1000',
                '-oX', '/tmp/nmap_temp.xml', target
            ], capture_output=True, text=True, timeout=600)
            
            # Parse XML result (simplificado)
            return {
                'command': f"nmap -sS -T4 --top-ports 1000 {target}",
                'exit_code': result.returncode,
                'xml_file': '/tmp/nmap_temp.xml'
            }
        except Exception as e:
            return {'error': str(e)}
    
    async def web_module(self, target: str) -> Dict:
        """Módulo de enumeración web"""
        import aiohttp
        
        results = {}
        protocols = ['http', 'https']
        
        async with aiohttp.ClientSession() as session:
            for protocol in protocols:
                try:
                    url = f"{protocol}://{target}"
                    async with session.get(url, timeout=10) as response:
                        results[protocol] = {
                            'status': response.status,
                            'headers': dict(response.headers),
                            'url': str(response.url)
                        }
                except Exception as e:
                    results[protocol] = {'error': str(e)}
        
        return results
    
    def generate_report(self, project_id: str, format='html') -> str:
        """Generar reporte de proyecto"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Obtener información del proyecto
        cursor.execute('SELECT * FROM projects WHERE id = ?', (project_id,))
        project = cursor.fetchone()
        
        # Obtener resultados
        cursor.execute('''
            SELECT module, result_type, data, created_at 
            FROM results WHERE project_id = ?
            ORDER BY created_at
        ''', (project_id,))
        results = cursor.fetchall()
        
        conn.close()
        
        if format == 'html':
            return self.generate_html_report(project, results)
        elif format == 'json':
            return self.generate_json_report(project, results)
    
    def generate_html_report(self, project, results) -> str:
        """Generar reporte HTML"""
        html_template = '''
        <!DOCTYPE html>
        <html>
        <head>
            <title>Recon Report - {project_name}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 40px; }}
                .header {{ background: #2c3e50; color: white; padding: 20px; }}
                .section {{ margin: 20px 0; padding: 15px; border-left: 4px solid #3498db; }}
                .result {{ background: #f8f9fa; padding: 10px; margin: 10px 0; border-radius: 5px; }}
                pre {{ background: #2c3e50; color: #ecf0f1; padding: 10px; overflow-x: auto; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>Reconnaissance Report</h1>
                <p>Target: {target}</p>
                <p>Generated: {timestamp}</p>
            </div>
            
            {results_html}
        </body>
        </html>
        '''
        
        results_html = ""
        for result in results:
            module, result_type, data, created_at = result
            results_html += f'''
            <div class="section">
                <h2>{module.capitalize()} Results</h2>
                <div class="result">
                    <strong>Type:</strong> {result_type}<br>
                    <strong>Timestamp:</strong> {created_at}<br>
                    <pre>{json.dumps(json.loads(data), indent=2)}</pre>
                </div>
            </div>
            '''
        
        return html_template.format(
            project_name=project[1],
            target=project[2],
            timestamp=datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            results_html=results_html
        )

# CLI Interface
class ReconCLI:
    def __init__(self):
        self.platform = ReconPlatform()
    
    async def run_scan(self, target: str, modules: List[str], project_name: str = None):
        """Ejecutar escaneo desde CLI"""
        if not project_name:
            project_name = f"Scan_{target}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        project_id = self.platform.create_project(project_name, target)
        await self.platform.run_reconnaissance(project_id, target, modules)
        
        # Generar reporte
        report_file = f"report_{project_id}.html"
        html_report = self.platform.generate_report(project_id, 'html')
        
        with open(report_file, 'w') as f:
            f.write(html_report)
        
        print(f"[+] Reconocimiento completado")
        print(f"[+] Reporte generado: {report_file}")

if __name__ == "__main__":
    import argparse
    
    parser = argparse.ArgumentParser(description='Plataforma de Reconocimiento')
    parser.add_argument('target', help='Objetivo del reconocimiento')
    parser.add_argument('-m', '--modules', nargs='+', 
                       choices=['whois', 'dns', 'subdomain', 'portscan', 'web'],
                       default=['whois', 'dns', 'subdomain', 'portscan', 'web'],
                       help='Módulos a ejecutar')
    parser.add_argument('-n', '--name', help='Nombre del proyecto')
    
    args = parser.parse_args()
    
    cli = ReconCLI()
    asyncio.run(cli.run_scan(args.target, args.modules, args.name))
```

### 15.3 Interfaz Web con Flask

```python
#!/usr/bin/env python3
# web_interface.py

from flask import Flask, render_template, request, jsonify, send_file
import asyncio
from recon_platform import ReconPlatform
import json
from datetime import datetime

app = Flask(__name__)
platform = ReconPlatform()

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/api/scan', methods=['POST'])
def start_scan():
    data = request.get_json()
    target = data.get('target')
    modules = data.get('modules', ['whois', 'dns'])
    project_name = data.get('project_name', f"Web_Scan_{datetime.now().strftime('%Y%m%d_%H%M%S')}")
    
    # Crear proyecto
    project_id = platform.create_project(project_name, target)
    
    # Ejecutar escaneo en background (simplificado)
    # En producción, usar Celery o similar
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)
    loop.run_until_complete(platform.run_reconnaissance(project_id, target, modules))
    
    return jsonify({
        'status': 'completed',
        'project_id': project_id,
        'message': 'Scan completed successfully'
    })

@app.route('/api/projects')
def get_projects():
    conn = platform.get_connection()
    cursor = conn.cursor()
    
    cursor.execute('SELECT * FROM projects ORDER BY created_at DESC')
    projects = cursor.fetchall()
    
    conn.close()
    
    return jsonify([{
        'id': p[0],
        'name': p[1],
        'target': p[2],
        'created_at': p[3],
        'status': p[4]